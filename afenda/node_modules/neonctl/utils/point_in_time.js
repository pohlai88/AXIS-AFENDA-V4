import { looksLikeLSN, looksLikeTimestamp } from './formats.js';
import { branchIdResolve } from './enrichers.js';
export class PointInTimeParseError extends Error {
    constructor(message) {
        super(message);
        this.name = 'PointInTimeParseError';
    }
}
export const parsePITBranch = (input) => {
    const splitIndex = input.lastIndexOf('@');
    const sourceBranch = splitIndex === -1 ? input : input.slice(0, splitIndex);
    const exactPIT = splitIndex === -1 ? null : input.slice(splitIndex + 1);
    const result = {
        branch: sourceBranch,
        ...(exactPIT === null
            ? { tag: 'head' }
            : looksLikeLSN(exactPIT)
                ? { tag: 'lsn', lsn: exactPIT }
                : { tag: 'timestamp', timestamp: exactPIT }),
    };
    if (result.tag === 'timestamp') {
        const timestamp = result.timestamp;
        if (!looksLikeTimestamp(timestamp)) {
            throw new PointInTimeParseError(`Invalid source branch format - ${input}`);
        }
        if (Date.parse(timestamp) > Date.now()) {
            throw new PointInTimeParseError(`Timestamp can not be in future - ${input}`);
        }
    }
    return result;
};
export const parsePointInTime = async ({ pointInTime, targetBranchId, projectId, api, }) => {
    const parsedPIT = parsePITBranch(pointInTime);
    let branchId = '';
    if (parsedPIT.branch === '^self') {
        branchId = targetBranchId;
    }
    else if (parsedPIT.branch === '^parent') {
        const { data } = await api.getProjectBranch(projectId, targetBranchId);
        const { parent_id: parentId } = data.branch;
        if (parentId == null) {
            throw new PointInTimeParseError('Branch has no parent');
        }
        branchId = parentId;
    }
    else {
        branchId = await branchIdResolve({
            branch: parsedPIT.branch,
            projectId,
            apiClient: api,
        });
    }
    // @ts-expect-error extracting pit from parsedPIT
    delete parsedPIT.branch;
    return { ...parsedPIT, branchId };
};
