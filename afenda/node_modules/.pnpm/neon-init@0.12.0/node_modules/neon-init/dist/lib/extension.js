import { existsSync } from "node:fs";
import { execa } from "execa";

//#region src/lib/extension.ts
const NEON_EXTENSION_ID = "databricks.neon-local-connect";
/**
* Uses macOS mdfind to locate an app by bundle identifier
*/
async function findAppWithMdfind(bundleId) {
	try {
		return (await execa("mdfind", [`kMDItemCFBundleIdentifier == '${bundleId}'`], { timeout: 5e3 })).stdout.trim().split("\n").filter(Boolean)[0] || null;
	} catch {
		return null;
	}
}
/**
* Known installation paths for VS Code CLI
*/
function getVSCodePaths() {
	const platform = process.platform;
	const home = process.env.HOME || "";
	if (platform === "darwin") return [
		"/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code",
		"/Applications/Visual Studio Code - Insiders.app/Contents/Resources/app/bin/code-insiders",
		`${home}/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code`,
		`${home}/Downloads/Visual Studio Code.app/Contents/Resources/app/bin/code`
	];
	if (platform === "linux") return [
		"/usr/share/code/bin/code",
		"/usr/bin/code",
		"/snap/bin/code",
		"/usr/share/code-insiders/bin/code-insiders"
	];
	if (platform === "win32") {
		const localAppData = process.env.LOCALAPPDATA || "";
		const programFiles = process.env.PROGRAMFILES || "C:\\Program Files";
		return [
			`${localAppData}\\Programs\\Microsoft VS Code\\bin\\code.cmd`,
			`${programFiles}\\Microsoft VS Code\\bin\\code.cmd`,
			`${localAppData}\\Programs\\Microsoft VS Code Insiders\\bin\\code-insiders.cmd`
		];
	}
	return [];
}
/**
* Known installation paths for Cursor CLI
*/
function getCursorPaths() {
	const platform = process.platform;
	const home = process.env.HOME || "";
	if (platform === "darwin") return [
		"/Applications/Cursor.app/Contents/Resources/app/bin/cursor",
		`${home}/Applications/Cursor.app/Contents/Resources/app/bin/cursor`,
		`${home}/Downloads/Cursor.app/Contents/Resources/app/bin/cursor`
	];
	if (platform === "linux") return [
		"/usr/share/cursor/bin/cursor",
		"/usr/bin/cursor",
		`${home}/.local/bin/cursor`,
		"/opt/cursor/bin/cursor"
	];
	if (platform === "win32") {
		const localAppData = process.env.LOCALAPPDATA || "";
		const programFiles = process.env.PROGRAMFILES || "C:\\Program Files";
		return [
			`${localAppData}\\Programs\\Cursor\\resources\\app\\bin\\cursor.cmd`,
			`${localAppData}\\cursor\\Cursor.exe`,
			`${programFiles}\\Cursor\\resources\\app\\bin\\cursor.cmd`
		];
	}
	return [];
}
/**
* Finds the CLI command for an editor by checking known installation paths
* On macOS, also uses mdfind to locate the app if standard paths fail
* Falls back to the simple command name if no full path is found (in case it's in PATH)
*/
async function findEditorCommand(editor) {
	let paths;
	let fallbackCommand;
	let bundleId = null;
	if (editor === "VS Code") {
		paths = getVSCodePaths();
		fallbackCommand = "code";
		bundleId = "com.microsoft.VSCode";
	} else if (editor === "Cursor") {
		paths = getCursorPaths();
		fallbackCommand = "cursor";
		bundleId = "com.todesktop.230313mzl4w4u92";
	} else return null;
	for (const path of paths) if (existsSync(path)) return path;
	if (process.platform === "darwin" && bundleId) {
		const appPath = await findAppWithMdfind(bundleId);
		if (appPath) {
			const cliPath = `${appPath}/Contents/Resources/app/bin/${fallbackCommand}`;
			if (existsSync(cliPath)) return cliPath;
		}
	}
	return fallbackCommand;
}
/**
* Gets the URI scheme for an editor
*/
function getEditorUriScheme(editor) {
	if (editor === "VS Code") return "vscode";
	if (editor === "Cursor") return "cursor";
	return null;
}
/**
* Checks if the extension is installed by querying the editor's extension list
*/
async function isExtensionInList(editor) {
	const command = await findEditorCommand(editor);
	if (!command) return false;
	try {
		return (await execa(command, ["--list-extensions"], { timeout: 5e3 })).stdout.includes(NEON_EXTENSION_ID);
	} catch {
		return false;
	}
}
/**
* Waits for the extension to appear in the installed extensions list
* This ensures the extension is fully installed and activated before we try to configure it
*/
async function waitForExtensionInstalled(editor, maxAttempts = 10, delayMs = 1e3) {
	for (let attempt = 0; attempt < maxAttempts; attempt++) {
		if (await isExtensionInList(editor)) {
			await new Promise((resolve) => setTimeout(resolve, 1e3));
			return true;
		}
		if (attempt < maxAttempts - 1) await new Promise((resolve) => setTimeout(resolve, delayMs));
	}
	return false;
}
/**
* Installs the Neon Local Connect extension for VS Code or Cursor
* Returns success only if installation succeeds, fails silently otherwise
*/
async function installExtension(editor) {
	const command = await findEditorCommand(editor);
	if (!command) return false;
	try {
		await execa(command, ["--install-extension", NEON_EXTENSION_ID]);
		return true;
	} catch {
		return false;
	}
}
/**
* Configures the Neon Local Connect extension with the API key
* Uses the extension's URI handler to trigger the import-api-key command
*/
async function configureExtension(editor, apiKey) {
	const scheme = getEditorUriScheme(editor);
	if (!scheme) return false;
	const uri = `${scheme}://${NEON_EXTENSION_ID}/import-api-key?token=${encodeURIComponent(apiKey)}`;
	try {
		const platform = process.platform;
		if (platform === "darwin") await execa("open", [uri], { timeout: 1e4 });
		else if (platform === "linux") await execa("xdg-open", [uri], { timeout: 1e4 });
		else if (platform === "win32") await execa("cmd", [
			"/c",
			"start",
			"",
			uri
		], { timeout: 1e4 });
		else return false;
		return true;
	} catch {
		return false;
	}
}
/**
* Returns the editor types that should use extension installation (vs MCP)
*/
function usesExtension(editor) {
	return editor === "VS Code" || editor === "Cursor";
}

//#endregion
export { configureExtension, findEditorCommand, installExtension, usesExtension, waitForExtensionInstalled };
//# sourceMappingURL=extension.js.map