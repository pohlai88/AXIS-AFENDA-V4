"use strict";
/* eslint-disable */
/* tslint:disable */
// @ts-nocheck
/*
 * ---------------------------------------------------------------
 * ## THIS FILE WAS GENERATED VIA SWAGGER-TYPESCRIPT-API        ##
 * ##                                                           ##
 * ## AUTHOR: acacode                                           ##
 * ## SOURCE: https://github.com/acacode/swagger-typescript-api ##
 * ---------------------------------------------------------------
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Api = exports.HttpClient = exports.ContentType = exports.ApplicationType = exports.SupportTicketSeverity = exports.NeonAuthEmailVerificationMethod = exports.NeonAuthOauthProviderType = exports.NeonAuthOauthProviderId = exports.NeonAuthProviderProjectTransferStatus = exports.NeonAuthProviderProjectOwnedBy = exports.NeonAuthSupportedAuthProvider = exports.OrgDeletionConditionName = exports.UserDeletionConditionName = exports.IdentityProviderId = exports.MemberRole = exports.BillingPaymentMethod = exports.BillingSubscriptionType = exports.BillingAccountState = exports.EndpointPoolerMode = exports.EndpointType = exports.EndpointState = exports.ProjectAuditLogLevel = exports.ConsumptionHistoryGranularity = exports.OperationStatus = exports.OperationAction = void 0;
/** The action performed by the operation */
var OperationAction;
(function (OperationAction) {
    OperationAction["CreateCompute"] = "create_compute";
    OperationAction["CreateTimeline"] = "create_timeline";
    OperationAction["StartCompute"] = "start_compute";
    OperationAction["SuspendCompute"] = "suspend_compute";
    OperationAction["ApplyConfig"] = "apply_config";
    OperationAction["CheckAvailability"] = "check_availability";
    OperationAction["DeleteTimeline"] = "delete_timeline";
    OperationAction["CreateBranch"] = "create_branch";
    OperationAction["ImportData"] = "import_data";
    OperationAction["TenantIgnore"] = "tenant_ignore";
    OperationAction["TenantAttach"] = "tenant_attach";
    OperationAction["TenantDetach"] = "tenant_detach";
    OperationAction["TenantReattach"] = "tenant_reattach";
    OperationAction["ReplaceSafekeeper"] = "replace_safekeeper";
    OperationAction["DisableMaintenance"] = "disable_maintenance";
    OperationAction["ApplyStorageConfig"] = "apply_storage_config";
    OperationAction["PrepareSecondaryPageserver"] = "prepare_secondary_pageserver";
    OperationAction["SwitchPageserver"] = "switch_pageserver";
    OperationAction["DetachParentBranch"] = "detach_parent_branch";
    OperationAction["TimelineArchive"] = "timeline_archive";
    OperationAction["TimelineUnarchive"] = "timeline_unarchive";
    OperationAction["StartReservedCompute"] = "start_reserved_compute";
    OperationAction["SyncDbsAndRolesFromCompute"] = "sync_dbs_and_roles_from_compute";
    OperationAction["ApplySchemaFromBranch"] = "apply_schema_from_branch";
    OperationAction["TimelineMarkInvisible"] = "timeline_mark_invisible";
    OperationAction["PrewarmReplica"] = "prewarm_replica";
    OperationAction["PromoteReplica"] = "promote_replica";
    OperationAction["SetStorageNonDirty"] = "set_storage_non_dirty";
})(OperationAction || (exports.OperationAction = OperationAction = {}));
/** The status of the operation */
var OperationStatus;
(function (OperationStatus) {
    OperationStatus["Scheduling"] = "scheduling";
    OperationStatus["Running"] = "running";
    OperationStatus["Finished"] = "finished";
    OperationStatus["Failed"] = "failed";
    OperationStatus["Error"] = "error";
    OperationStatus["Cancelling"] = "cancelling";
    OperationStatus["Cancelled"] = "cancelled";
    OperationStatus["Skipped"] = "skipped";
})(OperationStatus || (exports.OperationStatus = OperationStatus = {}));
var ConsumptionHistoryGranularity;
(function (ConsumptionHistoryGranularity) {
    ConsumptionHistoryGranularity["Hourly"] = "hourly";
    ConsumptionHistoryGranularity["Daily"] = "daily";
    ConsumptionHistoryGranularity["Monthly"] = "monthly";
})(ConsumptionHistoryGranularity || (exports.ConsumptionHistoryGranularity = ConsumptionHistoryGranularity = {}));
var ProjectAuditLogLevel;
(function (ProjectAuditLogLevel) {
    ProjectAuditLogLevel["Base"] = "base";
    ProjectAuditLogLevel["Extended"] = "extended";
    ProjectAuditLogLevel["Full"] = "full";
})(ProjectAuditLogLevel || (exports.ProjectAuditLogLevel = ProjectAuditLogLevel = {}));
/** The state of the compute endpoint */
var EndpointState;
(function (EndpointState) {
    EndpointState["Init"] = "init";
    EndpointState["Active"] = "active";
    EndpointState["Idle"] = "idle";
})(EndpointState || (exports.EndpointState = EndpointState = {}));
/** The compute endpoint type. Either `read_write` or `read_only`. */
var EndpointType;
(function (EndpointType) {
    EndpointType["ReadOnly"] = "read_only";
    EndpointType["ReadWrite"] = "read_write";
})(EndpointType || (exports.EndpointType = EndpointType = {}));
/** The connection pooler mode. Neon supports PgBouncer in `transaction` mode only. */
var EndpointPoolerMode;
(function (EndpointPoolerMode) {
    EndpointPoolerMode["Transaction"] = "transaction";
})(EndpointPoolerMode || (exports.EndpointPoolerMode = EndpointPoolerMode = {}));
/** State of the billing account. */
var BillingAccountState;
(function (BillingAccountState) {
    BillingAccountState["UNKNOWN"] = "UNKNOWN";
    BillingAccountState["Active"] = "active";
    BillingAccountState["Suspended"] = "suspended";
    BillingAccountState["Deactivated"] = "deactivated";
    BillingAccountState["Deleted"] = "deleted";
})(BillingAccountState || (exports.BillingAccountState = BillingAccountState = {}));
/**
 * Type of subscription to Neon Cloud.
 * Notice that for users without billing account this will be "UNKNOWN"
 */
var BillingSubscriptionType;
(function (BillingSubscriptionType) {
    BillingSubscriptionType["UNKNOWN"] = "UNKNOWN";
    BillingSubscriptionType["DirectSales"] = "direct_sales";
    BillingSubscriptionType["DirectSalesV3"] = "direct_sales_v3";
    BillingSubscriptionType["AwsMarketplace"] = "aws_marketplace";
    BillingSubscriptionType["FreeV2"] = "free_v2";
    BillingSubscriptionType["FreeV3"] = "free_v3";
    BillingSubscriptionType["Launch"] = "launch";
    BillingSubscriptionType["LaunchV3"] = "launch_v3";
    BillingSubscriptionType["Scale"] = "scale";
    BillingSubscriptionType["ScaleV3"] = "scale_v3";
    BillingSubscriptionType["Business"] = "business";
    BillingSubscriptionType["VercelPgLegacy"] = "vercel_pg_legacy";
})(BillingSubscriptionType || (exports.BillingSubscriptionType = BillingSubscriptionType = {}));
/** Indicates whether and how an account makes payments. */
var BillingPaymentMethod;
(function (BillingPaymentMethod) {
    BillingPaymentMethod["UNKNOWN"] = "UNKNOWN";
    BillingPaymentMethod["None"] = "none";
    BillingPaymentMethod["Stripe"] = "stripe";
    BillingPaymentMethod["DirectPayment"] = "direct_payment";
    BillingPaymentMethod["AwsMp"] = "aws_mp";
    BillingPaymentMethod["AzureMp"] = "azure_mp";
    BillingPaymentMethod["VercelMp"] = "vercel_mp";
    BillingPaymentMethod["Staff"] = "staff";
    BillingPaymentMethod["Trial"] = "trial";
    BillingPaymentMethod["Sponsorship"] = "sponsorship";
})(BillingPaymentMethod || (exports.BillingPaymentMethod = BillingPaymentMethod = {}));
/** The role of the organization member */
var MemberRole;
(function (MemberRole) {
    MemberRole["Admin"] = "admin";
    MemberRole["Member"] = "member";
})(MemberRole || (exports.MemberRole = MemberRole = {}));
/** Identity provider id from keycloak */
var IdentityProviderId;
(function (IdentityProviderId) {
    IdentityProviderId["Github"] = "github";
    IdentityProviderId["Google"] = "google";
    IdentityProviderId["Hasura"] = "hasura";
    IdentityProviderId["Microsoft"] = "microsoft";
    IdentityProviderId["Microsoftv2"] = "microsoftv2";
    IdentityProviderId["Vercelmp"] = "vercelmp";
    IdentityProviderId["Keycloak"] = "keycloak";
})(IdentityProviderId || (exports.IdentityProviderId = IdentityProviderId = {}));
var UserDeletionConditionName;
(function (UserDeletionConditionName) {
    UserDeletionConditionName["ProjectCount"] = "project_count";
    UserDeletionConditionName["OrgAdminMembershipCount"] = "org_admin_membership_count";
    UserDeletionConditionName["SubscriptionType"] = "subscription_type";
})(UserDeletionConditionName || (exports.UserDeletionConditionName = UserDeletionConditionName = {}));
var OrgDeletionConditionName;
(function (OrgDeletionConditionName) {
    OrgDeletionConditionName["ProjectCount"] = "project_count";
})(OrgDeletionConditionName || (exports.OrgDeletionConditionName = OrgDeletionConditionName = {}));
var NeonAuthSupportedAuthProvider;
(function (NeonAuthSupportedAuthProvider) {
    NeonAuthSupportedAuthProvider["Mock"] = "mock";
    NeonAuthSupportedAuthProvider["Stack"] = "stack";
    NeonAuthSupportedAuthProvider["StackV2"] = "stack_v2";
    NeonAuthSupportedAuthProvider["BetterAuth"] = "better_auth";
})(NeonAuthSupportedAuthProvider || (exports.NeonAuthSupportedAuthProvider = NeonAuthSupportedAuthProvider = {}));
var NeonAuthProviderProjectOwnedBy;
(function (NeonAuthProviderProjectOwnedBy) {
    NeonAuthProviderProjectOwnedBy["User"] = "user";
    NeonAuthProviderProjectOwnedBy["Neon"] = "neon";
})(NeonAuthProviderProjectOwnedBy || (exports.NeonAuthProviderProjectOwnedBy = NeonAuthProviderProjectOwnedBy = {}));
var NeonAuthProviderProjectTransferStatus;
(function (NeonAuthProviderProjectTransferStatus) {
    NeonAuthProviderProjectTransferStatus["Initiated"] = "initiated";
    NeonAuthProviderProjectTransferStatus["Finished"] = "finished";
})(NeonAuthProviderProjectTransferStatus || (exports.NeonAuthProviderProjectTransferStatus = NeonAuthProviderProjectTransferStatus = {}));
var NeonAuthOauthProviderId;
(function (NeonAuthOauthProviderId) {
    NeonAuthOauthProviderId["Google"] = "google";
    NeonAuthOauthProviderId["Github"] = "github";
    NeonAuthOauthProviderId["Microsoft"] = "microsoft";
    NeonAuthOauthProviderId["Vercel"] = "vercel";
})(NeonAuthOauthProviderId || (exports.NeonAuthOauthProviderId = NeonAuthOauthProviderId = {}));
var NeonAuthOauthProviderType;
(function (NeonAuthOauthProviderType) {
    NeonAuthOauthProviderType["Standard"] = "standard";
    NeonAuthOauthProviderType["Shared"] = "shared";
})(NeonAuthOauthProviderType || (exports.NeonAuthOauthProviderType = NeonAuthOauthProviderType = {}));
/**
 * The email verification method to use.
 * - `link`: Sends a verification link via email
 * - `otp`: Sends a one-time password (OTP) via email
 */
var NeonAuthEmailVerificationMethod;
(function (NeonAuthEmailVerificationMethod) {
    NeonAuthEmailVerificationMethod["Link"] = "link";
    NeonAuthEmailVerificationMethod["Otp"] = "otp";
})(NeonAuthEmailVerificationMethod || (exports.NeonAuthEmailVerificationMethod = NeonAuthEmailVerificationMethod = {}));
var SupportTicketSeverity;
(function (SupportTicketSeverity) {
    SupportTicketSeverity["Low"] = "low";
    SupportTicketSeverity["Normal"] = "normal";
    SupportTicketSeverity["High"] = "high";
    SupportTicketSeverity["Critical"] = "critical";
    SupportTicketSeverity["Urgent"] = "urgent";
})(SupportTicketSeverity || (exports.SupportTicketSeverity = SupportTicketSeverity = {}));
/** Type of application integration */
var ApplicationType;
(function (ApplicationType) {
    ApplicationType["Vercel"] = "vercel";
    ApplicationType["Github"] = "github";
    ApplicationType["Datadog"] = "datadog";
    ApplicationType["Opentelemetry"] = "opentelemetry";
})(ApplicationType || (exports.ApplicationType = ApplicationType = {}));
var axios_1 = __importDefault(require("axios"));
var ContentType;
(function (ContentType) {
    ContentType["Json"] = "application/json";
    ContentType["FormData"] = "multipart/form-data";
    ContentType["UrlEncoded"] = "application/x-www-form-urlencoded";
    ContentType["Text"] = "text/plain";
})(ContentType || (exports.ContentType = ContentType = {}));
var HttpClient = /** @class */ (function () {
    function HttpClient(_a) {
        if (_a === void 0) { _a = {}; }
        var _this = this;
        var securityWorker = _a.securityWorker, secure = _a.secure, format = _a.format, axiosConfig = __rest(_a, ["securityWorker", "secure", "format"]);
        this.securityData = null;
        this.setSecurityData = function (data) {
            _this.securityData = data;
        };
        this.request = function (_a) { return __awaiter(_this, void 0, void 0, function () {
            var secureParams, _b, requestParams, responseFormat;
            var secure = _a.secure, path = _a.path, type = _a.type, query = _a.query, format = _a.format, body = _a.body, params = __rest(_a, ["secure", "path", "type", "query", "format", "body"]);
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _b = (typeof secure === 'boolean' ? secure : this.secure) &&
                            this.securityWorker;
                        if (!_b) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.securityWorker(this.securityData)];
                    case 1:
                        _b = (_c.sent());
                        _c.label = 2;
                    case 2:
                        secureParams = (_b) ||
                            {};
                        requestParams = this.mergeRequestParams(params, secureParams);
                        responseFormat = format || this.format || undefined;
                        if (type === ContentType.FormData && body && body !== null && typeof body === 'object') {
                            body = this.createFormData(body);
                        }
                        if (type === ContentType.Text && body && body !== null && typeof body !== 'string') {
                            body = JSON.stringify(body);
                        }
                        return [2 /*return*/, this.instance.request(__assign(__assign({}, requestParams), { headers: __assign(__assign({}, (requestParams.headers || {})), (type ? { 'Content-Type': type } : {})), params: query, responseType: responseFormat, data: body, url: path }))];
                }
            });
        }); };
        this.instance = axios_1.default.create(__assign(__assign({}, axiosConfig), { baseURL: axiosConfig.baseURL || 'https://console.neon.tech/api/v2' }));
        this.secure = secure;
        this.format = format;
        this.securityWorker = securityWorker;
    }
    HttpClient.prototype.mergeRequestParams = function (params1, params2) {
        var method = params1.method || (params2 && params2.method);
        return __assign(__assign(__assign(__assign({}, this.instance.defaults), params1), (params2 || {})), { headers: __assign(__assign(__assign({}, ((method && this.instance.defaults.headers[method.toLowerCase()]) || {})), (params1.headers || {})), ((params2 && params2.headers) || {})) });
    };
    HttpClient.prototype.stringifyFormItem = function (formItem) {
        if (typeof formItem === 'object' && formItem !== null) {
            return JSON.stringify(formItem);
        }
        else {
            return "".concat(formItem);
        }
    };
    HttpClient.prototype.createFormData = function (input) {
        var _this = this;
        if (input instanceof FormData) {
            return input;
        }
        return Object.keys(input || {}).reduce(function (formData, key) {
            var property = input[key];
            var propertyContent = property instanceof Array ? property : [property];
            for (var _i = 0, propertyContent_1 = propertyContent; _i < propertyContent_1.length; _i++) {
                var formItem = propertyContent_1[_i];
                var isFileType = formItem instanceof Blob || formItem instanceof File;
                formData.append(key, isFileType ? formItem : _this.stringifyFormItem(formItem));
            }
            return formData;
        }, new FormData());
    };
    return HttpClient;
}());
exports.HttpClient = HttpClient;
/**
 * @title Neon API
 * @version v2
 * @license Proprietary
 * @baseUrl https://console.neon.tech/api/v2
 * @contact <help@databricks.com>
 *
 * The Neon API allows you to access and manage Neon programmatically. You can use the Neon API to manage API keys, projects, branches, compute endpoints, databases, roles, and operations. For information about these features, refer to the [Neon documentation](https://neon.tech/docs/manage/overview/).
 *
 * You can run Neon API requests from this API reference using the **Try It** feature. Enter your API key as a **Bearer** token in the **Authorization** section of the page.
 *
 * You can create and manage API keys in the Neon Console. See [Manage API keys](https://neon.tech/docs/manage/api-keys/) for instructions.
 */
var Api = /** @class */ (function (_super) {
    __extends(Api, _super);
    function Api() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * @description Retrieves the API keys for your Neon account. The response does not include API key tokens. A token is only provided when creating an API key. API keys can also be managed in the Neon Console. For more information, see [Manage API keys](https://neon.tech/docs/manage/api-keys/).
         *
         * @tags API Key
         * @name ListApiKeys
         * @summary List API keys
         * @request GET:/api_keys
         * @secure
         */
        _this.listApiKeys = function (params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/api_keys", method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Creates an API key. The `key_name` is a user-specified name for the key. This method returns an `id` and `key`. The `key` is a randomly generated, 64-bit token required to access the Neon API. API keys can also be managed in the Neon Console. See [Manage API keys](https://neon.tech/docs/manage/api-keys/).
         *
         * @tags API Key
         * @name CreateApiKey
         * @summary Create API key
         * @request POST:/api_keys
         * @secure
         */
        _this.createApiKey = function (data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/api_keys", method: 'POST', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Revokes the specified API key. An API key that is no longer needed can be revoked. This action cannot be reversed. You can obtain `key_id` values by listing the API keys for your Neon account. API keys can also be managed in the Neon Console. See [Manage API keys](https://neon.tech/docs/manage/api-keys/).
         *
         * @tags API Key
         * @name RevokeApiKey
         * @summary Revoke API key
         * @request DELETE:/api_keys/{key_id}
         * @secure
         */
        _this.revokeApiKey = function (keyId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/api_keys/".concat(encodeURIComponent(keyId)), method: 'DELETE', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves details for the specified operation. An operation is an action performed on a Neon project resource. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain a `operation_id` by listing operations for the project.
         *
         * @tags Operation
         * @name GetProjectOperation
         * @summary Retrieve operation details
         * @request GET:/projects/{project_id}/operations/{operation_id}
         * @secure
         */
        _this.getProjectOperation = function (projectId, operationId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/operations/").concat(encodeURIComponent(operationId)), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves a list of projects for an organization. You may need to specify an org_id parameter depending on your API key type. For more information, see [Manage projects](https://neon.tech/docs/manage/projects/).
         *
         * @tags Project
         * @name ListProjects
         * @summary List projects
         * @request GET:/projects
         * @secure
         */
        _this.listProjects = function (query, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects", method: 'GET', query: query, secure: true, format: 'json' }, params));
        };
        /**
         * @description Creates a Neon project within an organization. You may need to specify an org_id parameter depending on your API key type. Plan limits define how many projects you can create. For more information, see [Manage projects](https://neon.tech/docs/manage/projects/). You can specify a region and Postgres version in the request body. Neon currently supports PostgreSQL 14, 15, 16, and 17. For supported regions and `region_id` values, see [Regions](https://neon.tech/docs/introduction/regions/).
         *
         * @tags Project
         * @name CreateProject
         * @summary Create project
         * @request POST:/projects
         * @secure
         */
        _this.createProject = function (data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects", method: 'POST', body: data, secure: true, type: ContentType.Json }, params));
        };
        /**
         * @description Retrieves a list of projects shared with your Neon account. For more information, see [Manage projects](https://neon.tech/docs/manage/projects/).
         *
         * @tags Project
         * @name ListSharedProjects
         * @summary List shared projects
         * @request GET:/projects/shared
         * @secure
         */
        _this.listSharedProjects = function (query, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/shared", method: 'GET', query: query, secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves information about the specified project. You can obtain a `project_id` by listing the projects for an organization.
         *
         * @tags Project
         * @name GetProject
         * @summary Retrieve project details
         * @request GET:/projects/{project_id}
         * @secure
         */
        _this.getProject = function (projectId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId)), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Updates the specified project. You can obtain a `project_id` by listing the projects for your Neon account.
         *
         * @tags Project
         * @name UpdateProject
         * @summary Update project
         * @request PATCH:/projects/{project_id}
         * @secure
         */
        _this.updateProject = function (projectId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId)), method: 'PATCH', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Deletes the specified project. You can obtain a `project_id` by listing the projects for your Neon account. Deleting a project is a permanent action. Deleting a project also deletes endpoints, branches, databases, and users that belong to the project.
         *
         * @tags Project
         * @name DeleteProject
         * @summary Delete project
         * @request DELETE:/projects/{project_id}
         * @secure
         */
        _this.deleteProject = function (projectId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId)), method: 'DELETE', secure: true, format: 'json' }, params));
        };
        /**
         * @description DEPRECATED, use `/projects/{project_id}/recover` instead. Restores a deleted project during the deletion grace period. You can obtain a `project_id` by listing the projects for your Neon account. **Note**: This endpoint is currently in Private Preview.
         *
         * @tags Project
         * @name RestoreProject
         * @summary Restore a deleted project
         * @request POST:/projects/{project_id}/restore
         * @deprecated
         * @secure
         */
        _this.restoreProject = function (projectId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/restore"), method: 'POST', secure: true, format: 'json' }, params));
        };
        /**
         * @description Recovers a deleted project during the deletion grace period. You can obtain a `project_id` by listing the projects for your Neon account. **Note**: This endpoint is currently in Private Preview.
         *
         * @tags Project
         * @name RecoverProject
         * @summary Recover a deleted project
         * @request POST:/projects/{project_id}/recover
         * @secure
         */
        _this.recoverProject = function (projectId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/recover"), method: 'POST', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves a list of operations for the specified Neon project. You can obtain a `project_id` by listing the projects for your Neon account. The number of operations returned can be large. To paginate the response, issue an initial request with a `limit` value. Then, add the `cursor` value that was returned in the response to the next request. Operations older than 6 months may be deleted from our systems. If you need more history than that, you should store your own history.
         *
         * @tags Operation
         * @name ListProjectOperations
         * @summary List operations
         * @request GET:/projects/{project_id}/operations
         * @secure
         */
        _this.listProjectOperations = function (_a, params) {
            var projectId = _a.projectId, query = __rest(_a, ["projectId"]);
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/operations"), method: 'GET', query: query, secure: true }, params));
        };
        /**
         * @description Retrieves details about users who have access to the project, including the permission `id`, the granted-to email address, and the date project access was granted.
         *
         * @tags Project
         * @name ListProjectPermissions
         * @summary List project access
         * @request GET:/projects/{project_id}/permissions
         * @secure
         */
        _this.listProjectPermissions = function (projectId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/permissions"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Grants project access to the account associated with the specified email address
         *
         * @tags Project
         * @name GrantPermissionToProject
         * @summary Grant project access
         * @request POST:/projects/{project_id}/permissions
         * @secure
         */
        _this.grantPermissionToProject = function (projectId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/permissions"), method: 'POST', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Revokes project access from the user associated with the specified permission `id`. You can retrieve a user's permission `id` by listing project access.
         *
         * @tags Project
         * @name RevokePermissionFromProject
         * @summary Revoke project access
         * @request DELETE:/projects/{project_id}/permissions/{permission_id}
         * @secure
         */
        _this.revokePermissionFromProject = function (projectId, permissionId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/permissions/").concat(encodeURIComponent(permissionId)), method: 'DELETE', secure: true, format: 'json' }, params));
        };
        /**
         * @description Return available shared preload libraries
         *
         * @tags Project
         * @name GetAvailablePreloadLibraries
         * @summary Return available shared preload libraries
         * @request GET:/projects/{project_id}/available_preload_libraries
         * @secure
         */
        _this.getAvailablePreloadLibraries = function (projectId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/available_preload_libraries"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Creates a transfer request for the specified project. A transfer request allows the project to be transferred to another account or organization. The request has an expiration time after which it can no longer be used. To accept/claim the transfer request, the recipient user/organization must call the `/projects/{project_id}/transfer_requests/{request_id}` API endpoint, or visit `https://console.neon.tech/app/claim?p={project_id}&tr={request_id}&ru={redirect_url}` in the Neon Console. The `ru` parameter is optional and can be used to redirect the user after accepting the transfer request.
         *
         * @tags Project
         * @name CreateProjectTransferRequest
         * @summary Create a project transfer request
         * @request POST:/projects/{project_id}/transfer_requests
         * @secure
         */
        _this.createProjectTransferRequest = function (projectId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/transfer_requests"), method: 'POST', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Accepts a transfer request for the specified project, transferring it to the specified organization or user. If org_id is not passed, the project will be transferred to the current user or organization account.
         *
         * @tags Project
         * @name AcceptProjectTransferRequest
         * @summary Accept a project transfer request
         * @request PUT:/projects/{project_id}/transfer_requests/{request_id}
         * @secure
         */
        _this.acceptProjectTransferRequest = function (projectId, requestId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/transfer_requests/").concat(encodeURIComponent(requestId)), method: 'PUT', body: data, secure: true, type: ContentType.Json }, params));
        };
        /**
         * @description Returns the JWKS URLs available for verifying JWTs used as the authentication mechanism for the specified project.
         *
         * @tags Project
         * @name GetProjectJwks
         * @summary List JWKS URLs
         * @request GET:/projects/{project_id}/jwks
         * @secure
         */
        _this.getProjectJwks = function (projectId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/jwks"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Add a new JWKS URL to a project, such that it can be used for verifying JWTs used as the authentication mechanism for the specified project. The URL must be a valid HTTPS URL that returns a JSON Web Key Set. The `provider_name` field allows you to specify which authentication provider you're using (e.g., Clerk, Auth0, AWS Cognito, etc.). The `branch_id` can be used to specify on which branches the JWKS URL will be accepted. If not specified, then it will work on any branch. The `role_names` can be used to specify for which roles the JWKS URL will be accepted. If not specified, then default roles will be used (authenticator, authenticated and anonymous). The `jwt_audience` can be used to specify which "aud" values should be accepted by Neon in the JWTs that are used for authentication.
         *
         * @tags Project
         * @name AddProjectJwks
         * @summary Add JWKS URL
         * @request POST:/projects/{project_id}/jwks
         * @secure
         */
        _this.addProjectJwks = function (projectId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/jwks"), method: 'POST', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Deletes a JWKS URL from the specified project
         *
         * @tags Project
         * @name DeleteProjectJwks
         * @summary Delete JWKS URL
         * @request DELETE:/projects/{project_id}/jwks/{jwks_id}
         * @secure
         */
        _this.deleteProjectJwks = function (projectId, jwksId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/jwks/").concat(encodeURIComponent(jwksId)), method: 'DELETE', secure: true, format: 'json' }, params));
        };
        /**
         * @description Creates a new instance of Neon Data API in the specified branch. You can obtain the `project_id` and `branch_id` by listing the projects and branches for your Neon account.
         *
         * @tags DataAPI
         * @name CreateProjectBranchDataApi
         * @summary Create Neon Data API
         * @request POST:/projects/{project_id}/branches/{branch_id}/data-api/{database_name}
         * @secure
         */
        _this.createProjectBranchDataApi = function (projectId, branchId, databaseName, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/data-api/").concat(encodeURIComponent(databaseName)), method: 'POST', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Updates the Neon Data API configuration for the specified branch. You can optionally provide settings to update the Data API configuration. The schema cache is always refreshed as part of this operation. You can obtain the `project_id` and `branch_id` by listing the projects and branches for your Neon account.
         *
         * @tags DataAPI
         * @name UpdateProjectBranchDataApi
         * @summary Update Neon Data API
         * @request PATCH:/projects/{project_id}/branches/{branch_id}/data-api/{database_name}
         * @secure
         */
        _this.updateProjectBranchDataApi = function (projectId, branchId, databaseName, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/data-api/").concat(encodeURIComponent(databaseName)), method: 'PATCH', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Deletes the Neon Data API for the specified branch. You can obtain the `project_id` and `branch_id` by listing the projects and branches for your Neon account.
         *
         * @tags DataAPI
         * @name DeleteProjectBranchDataApi
         * @summary Delete Neon Data API
         * @request DELETE:/projects/{project_id}/branches/{branch_id}/data-api/{database_name}
         * @secure
         */
        _this.deleteProjectBranchDataApi = function (projectId, branchId, databaseName, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/data-api/").concat(encodeURIComponent(databaseName)), method: 'DELETE', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves the Neon Data API for the specified branch.
         *
         * @tags DataAPI
         * @name GetProjectBranchDataApi
         * @summary Get Neon Data API
         * @request GET:/projects/{project_id}/branches/{branch_id}/data-api/{database_name}
         * @secure
         */
        _this.getProjectBranchDataApi = function (projectId, branchId, databaseName, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/data-api/").concat(encodeURIComponent(databaseName)), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description DEPRECATED, use `/projects/{project_id}/branches/{branch_id}/auth` instead. Creates a project on a third-party authentication provider's platform for use with Neon Auth. Use this endpoint if the frontend integration flow can't be used.
         *
         * @tags Auth (legacy)
         * @name CreateNeonAuthIntegration
         * @summary Create Neon Auth integration
         * @request POST:/projects/auth/create
         * @deprecated
         * @secure
         */
        _this.createNeonAuthIntegration = function (data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/auth/create", method: 'POST', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description / Fetches the details of the Neon Auth for the specified branch. You can obtain the `project_id` and `branch_id` by listing the projects and branches for your Neon account.
         *
         * @tags Auth
         * @name GetNeonAuth
         * @summary Get details of Neon Auth for the branch
         * @request GET:/projects/{project_id}/branches/{branch_id}/auth
         * @secure
         */
        _this.getNeonAuth = function (projectId, branchId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/auth"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Enables Neon Auth integrationfor the branch. You can obtain the `project_id` and `branch_id` by listing the projects and branches for your Neon account.
         *
         * @tags Auth
         * @name CreateNeonAuth
         * @summary Enable Neon Auth for the branch
         * @request POST:/projects/{project_id}/branches/{branch_id}/auth
         * @secure
         */
        _this.createNeonAuth = function (projectId, branchId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/auth"), method: 'POST', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * No description
         *
         * @tags Auth
         * @name DisableNeonAuth
         * @summary Disables Neon Auth for the branch
         * @request DELETE:/projects/{project_id}/branches/{branch_id}/auth
         * @secure
         */
        _this.disableNeonAuth = function (projectId, branchId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/auth"), method: 'DELETE', body: data, secure: true, type: ContentType.Json }, params));
        };
        /**
         * @description DEPRECATED, use `/projects/{project_id}/branches/{branch_id}/auth/domains` instead. Lists the domains in the redirect_uri whitelist for the specified project.
         *
         * @tags Auth (legacy)
         * @name ListNeonAuthRedirectUriWhitelistDomains
         * @summary List domains in redirect_uri whitelist
         * @request GET:/projects/{project_id}/auth/domains
         * @deprecated
         * @secure
         */
        _this.listNeonAuthRedirectUriWhitelistDomains = function (projectId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/auth/domains"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description DEPRECATED, use `/projects/{project_id}/branches/{branch_id}/auth/domains` instead. Adds a domain to the redirect_uri whitelist for the specified project.
         *
         * @tags Auth (legacy)
         * @name AddNeonAuthDomainToRedirectUriWhitelist
         * @summary Add domain to redirect_uri whitelist
         * @request POST:/projects/{project_id}/auth/domains
         * @deprecated
         * @secure
         */
        _this.addNeonAuthDomainToRedirectUriWhitelist = function (projectId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/auth/domains"), method: 'POST', body: data, secure: true, type: ContentType.Json }, params));
        };
        /**
         * @description DEPRECATED, use `/projects/{project_id}/branches/{branch_id}/auth/domains` instead. Deletes a domain from the redirect_uri whitelist for the specified project.
         *
         * @tags Auth (legacy)
         * @name DeleteNeonAuthDomainFromRedirectUriWhitelist
         * @summary Delete domain from redirect_uri whitelist
         * @request DELETE:/projects/{project_id}/auth/domains
         * @deprecated
         * @secure
         */
        _this.deleteNeonAuthDomainFromRedirectUriWhitelist = function (projectId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/auth/domains"), method: 'DELETE', body: data, secure: true, type: ContentType.Json }, params));
        };
        /**
         * @description Lists the domains in the redirect_uri whitelist for the specified project.
         *
         * @tags Auth
         * @name ListBranchNeonAuthTrustedDomains
         * @summary List domains in redirect_uri whitelist
         * @request GET:/projects/{project_id}/branches/{branch_id}/auth/domains
         * @secure
         */
        _this.listBranchNeonAuthTrustedDomains = function (projectId, branchId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/auth/domains"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Adds a domain to the redirect_uri whitelist for the specified project.
         *
         * @tags Auth
         * @name AddBranchNeonAuthTrustedDomain
         * @summary Add domain to redirect_uri whitelist
         * @request POST:/projects/{project_id}/branches/{branch_id}/auth/domains
         * @secure
         */
        _this.addBranchNeonAuthTrustedDomain = function (projectId, branchId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/auth/domains"), method: 'POST', body: data, secure: true, type: ContentType.Json }, params));
        };
        /**
         * @description Deletes a domain from the redirect_uri whitelist for the specified project.
         *
         * @tags Auth
         * @name DeleteBranchNeonAuthTrustedDomain
         * @summary Delete domain from redirect_uri whitelist
         * @request DELETE:/projects/{project_id}/branches/{branch_id}/auth/domains
         * @secure
         */
        _this.deleteBranchNeonAuthTrustedDomain = function (projectId, branchId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/auth/domains"), method: 'DELETE', body: data, secure: true, type: ContentType.Json }, params));
        };
        /**
         * @description Generates SDK or API Keys for the auth provider. These might be called different things depending on the auth provider you're using, but are generally used for setting up the frontend and backend SDKs.
         *
         * @tags Auth (legacy)
         * @name CreateNeonAuthProviderSdkKeys
         * @summary Create Auth Provider SDK keys
         * @request POST:/projects/auth/keys
         * @secure
         */
        _this.createNeonAuthProviderSdkKeys = function (data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/auth/keys", method: 'POST', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description DEPRECATED, use `/projects/{project_id}/branches/{branch_id}/auth/users` instead. Creates a new user in Neon Auth. The user will be created in your neon_auth.users_sync table and automatically propagated to your auth project, whether Neon-managed or provider-owned.
         *
         * @tags Auth (legacy)
         * @name CreateNeonAuthNewUser
         * @summary Create new auth user
         * @request POST:/projects/auth/user
         * @deprecated
         * @secure
         */
        _this.createNeonAuthNewUser = function (data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/auth/user", method: 'POST', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Creates a new user in Neon Auth.
         *
         * @tags Auth
         * @name CreateBranchNeonAuthNewUser
         * @summary Create new auth user
         * @request POST:/projects/{project_id}/branches/{branch_id}/auth/users
         * @secure
         */
        _this.createBranchNeonAuthNewUser = function (projectId, branchId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/auth/users"), method: 'POST', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Deletes the auth user for the specified project.
         *
         * @tags Auth
         * @name DeleteBranchNeonAuthUser
         * @summary Delete auth user
         * @request DELETE:/projects/{project_id}/branches/{branch_id}/auth/users/{auth_user_id}
         * @secure
         */
        _this.deleteBranchNeonAuthUser = function (projectId, branchId, authUserId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/auth/users/").concat(encodeURIComponent(authUserId)), method: 'DELETE', secure: true }, params));
        };
        /**
         * @description Updates the role of an auth user for the specified project.
         *
         * @tags Auth
         * @name UpdateNeonAuthUserRole
         * @summary Update auth user role
         * @request PUT:/projects/{project_id}/branches/{branch_id}/auth/users/{auth_user_id}/role
         * @secure
         */
        _this.updateNeonAuthUserRole = function (projectId, branchId, authUserId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/auth/users/").concat(encodeURIComponent(authUserId), "/role"), method: 'PUT', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description DEPRECATED, use `/projects/{project_id}/branches/{branch_id}/auth/users/{auth_user_id}` instead. Deletes the auth user for the specified project.
         *
         * @tags Auth (legacy)
         * @name DeleteNeonAuthUser
         * @summary Delete auth user
         * @request DELETE:/projects/{project_id}/auth/users/{auth_user_id}
         * @deprecated
         * @secure
         */
        _this.deleteNeonAuthUser = function (projectId, authUserId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/auth/users/").concat(encodeURIComponent(authUserId)), method: 'DELETE', secure: true }, params));
        };
        /**
         * @description Transfer ownership of your Neon-managed auth project to your own auth provider account.
         *
         * @tags Auth (legacy)
         * @name TransferNeonAuthProviderProject
         * @summary Transfer Neon-managed auth project to your own account
         * @request POST:/projects/auth/transfer_ownership
         * @secure
         */
        _this.transferNeonAuthProviderProject = function (data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/auth/transfer_ownership", method: 'POST', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description DEPRECATED, use `/projects/{project_id}/branches/{branch_id}/auth` instead.
         *
         * @tags Auth (legacy)
         * @name ListNeonAuthIntegrations
         * @summary Lists active integrations with auth providers
         * @request GET:/projects/{project_id}/auth/integrations
         * @deprecated
         * @secure
         */
        _this.listNeonAuthIntegrations = function (projectId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/auth/integrations"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description DEPRECATED, use `/projects/{project_id}/branches/{branch_id}/auth/oauth_providers` instead. Lists the OAuth providers for the specified project.
         *
         * @tags Auth (legacy)
         * @name ListNeonAuthOauthProviders
         * @summary List OAuth providers
         * @request GET:/projects/{project_id}/auth/oauth_providers
         * @deprecated
         * @secure
         */
        _this.listNeonAuthOauthProviders = function (projectId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/auth/oauth_providers"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description DEPRECATED, use `/projects/{project_id}/branches/{branch_id}/auth/oauth_providers` instead. Adds a OAuth provider to the specified project.
         *
         * @tags Auth (legacy)
         * @name AddNeonAuthOauthProvider
         * @summary Add a OAuth provider
         * @request POST:/projects/{project_id}/auth/oauth_providers
         * @deprecated
         * @secure
         */
        _this.addNeonAuthOauthProvider = function (projectId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/auth/oauth_providers"), method: 'POST', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Lists the OAuth providers for the specified project and branch.
         *
         * @tags Auth
         * @name ListBranchNeonAuthOauthProviders
         * @summary List OAuth providers for neon auth for a branch
         * @request GET:/projects/{project_id}/branches/{branch_id}/auth/oauth_providers
         * @secure
         */
        _this.listBranchNeonAuthOauthProviders = function (projectId, branchId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/auth/oauth_providers"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Adds a OAuth provider to the specified project.
         *
         * @tags Auth
         * @name AddBranchNeonAuthOauthProvider
         * @summary Add a OAuth provider
         * @request POST:/projects/{project_id}/branches/{branch_id}/auth/oauth_providers
         * @secure
         */
        _this.addBranchNeonAuthOauthProvider = function (projectId, branchId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/auth/oauth_providers"), method: 'POST', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description DEPRECATED, use `/projects/{project_id}/branches/{branch_id}/auth/oauth_providers/{oauth_provider_id}` instead. Updates a OAuth provider for the specified project.
         *
         * @tags Auth (legacy)
         * @name UpdateNeonAuthOauthProvider
         * @summary Update OAuth provider
         * @request PATCH:/projects/{project_id}/auth/oauth_providers/{oauth_provider_id}
         * @deprecated
         * @secure
         */
        _this.updateNeonAuthOauthProvider = function (projectId, oauthProviderId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/auth/oauth_providers/").concat(encodeURIComponent(oauthProviderId)), method: 'PATCH', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description DEPRECATED, use `/projects/{project_id}/branches/{branch_id}/auth/oauth_providers/{oauth_provider_id}` instead. Deletes a OAuth provider from the specified project.
         *
         * @tags Auth (legacy)
         * @name DeleteNeonAuthOauthProvider
         * @summary Delete OAuth provider
         * @request DELETE:/projects/{project_id}/auth/oauth_providers/{oauth_provider_id}
         * @deprecated
         * @secure
         */
        _this.deleteNeonAuthOauthProvider = function (projectId, oauthProviderId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/auth/oauth_providers/").concat(encodeURIComponent(oauthProviderId)), method: 'DELETE', secure: true }, params));
        };
        /**
         * @description Updates a OAuth provider for the specified project.
         *
         * @tags Auth
         * @name UpdateBranchNeonAuthOauthProvider
         * @summary Update OAuth provider
         * @request PATCH:/projects/{project_id}/branches/{branch_id}/auth/oauth_providers/{oauth_provider_id}
         * @secure
         */
        _this.updateBranchNeonAuthOauthProvider = function (projectId, branchId, oauthProviderId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/auth/oauth_providers/").concat(encodeURIComponent(oauthProviderId)), method: 'PATCH', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Deletes a OAuth provider from the specified project.
         *
         * @tags Auth
         * @name DeleteBranchNeonAuthOauthProvider
         * @summary Delete OAuth provider
         * @request DELETE:/projects/{project_id}/branches/{branch_id}/auth/oauth_providers/{oauth_provider_id}
         * @secure
         */
        _this.deleteBranchNeonAuthOauthProvider = function (projectId, branchId, oauthProviderId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/auth/oauth_providers/").concat(encodeURIComponent(oauthProviderId)), method: 'DELETE', secure: true }, params));
        };
        /**
         * @description DEPRECATED, use `/projects/{project_id}/branches/{branch_id}/auth/email_provider` instead. Gets the email server configuration for the specified project.
         *
         * @tags Auth (legacy)
         * @name GetNeonAuthEmailServer
         * @summary Get email server configuration
         * @request GET:/projects/{project_id}/auth/email_server
         * @deprecated
         * @secure
         */
        _this.getNeonAuthEmailServer = function (projectId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/auth/email_server"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description DEPRECATED, use `/projects/{project_id}/branches/{branch_id}/auth/email_provider` instead. Updates the email server configuration for the specified project.
         *
         * @tags Auth (legacy)
         * @name UpdateNeonAuthEmailServer
         * @summary Update email server configuration
         * @request PATCH:/projects/{project_id}/auth/email_server
         * @deprecated
         * @secure
         */
        _this.updateNeonAuthEmailServer = function (projectId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/auth/email_server"), method: 'PATCH', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Sends a test email to the specified email address.
         *
         * @tags Auth
         * @name SendNeonAuthTestEmail
         * @summary Send test email
         * @request POST:/projects/{project_id}/branches/{branch_id}/auth/send_test_email
         * @secure
         */
        _this.sendNeonAuthTestEmail = function (projectId, branchId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/auth/send_test_email"), method: 'POST', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Gets the email and password authentication configuration for Neon Auth
         *
         * @tags Auth
         * @name GetNeonAuthEmailAndPasswordConfig
         * @summary Get email and password configuration
         * @request GET:/projects/{project_id}/branches/{branch_id}/auth/email_and_password
         * @secure
         */
        _this.getNeonAuthEmailAndPasswordConfig = function (projectId, branchId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/auth/email_and_password"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Updates the email and password authentication configuration for Neon Auth
         *
         * @tags Auth
         * @name UpdateNeonAuthEmailAndPasswordConfig
         * @summary Update email and password configuration
         * @request PATCH:/projects/{project_id}/branches/{branch_id}/auth/email_and_password
         * @secure
         */
        _this.updateNeonAuthEmailAndPasswordConfig = function (projectId, branchId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/auth/email_and_password"), method: 'PATCH', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Gets the email provider configuration for the specified branch.
         *
         * @tags Auth
         * @name GetNeonAuthEmailProvider
         * @summary Get email provider configuration
         * @request GET:/projects/{project_id}/branches/{branch_id}/auth/email_provider
         * @secure
         */
        _this.getNeonAuthEmailProvider = function (projectId, branchId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/auth/email_provider"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Updates the email provider configuration for the specified branch.
         *
         * @tags Auth
         * @name UpdateNeonAuthEmailProvider
         * @summary Update email provider configuration
         * @request PATCH:/projects/{project_id}/branches/{branch_id}/auth/email_provider
         * @secure
         */
        _this.updateNeonAuthEmailProvider = function (projectId, branchId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/auth/email_provider"), method: 'PATCH', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description DEPRECATED, use `/projects/{project_id}/branches/{branch_id}/auth` instead.
         *
         * @tags Auth (legacy)
         * @name DeleteNeonAuthIntegration
         * @summary Delete integration with auth provider
         * @request DELETE:/projects/{project_id}/auth/integration/{auth_provider}
         * @deprecated
         * @secure
         */
        _this.deleteNeonAuthIntegration = function (projectId, authProvider, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/auth/integration/").concat(encodeURIComponent(authProvider)), method: 'DELETE', body: data, secure: true, type: ContentType.Json }, params));
        };
        /**
         * @description Retrieves a connection URI for the specified database. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `database_name` by listing the databases for a branch. You can obtain a `role_name` by listing the roles for a branch.
         *
         * @tags Project
         * @name GetConnectionUri
         * @summary Retrieve connection URI
         * @request GET:/projects/{project_id}/connection_uri
         * @secure
         */
        _this.getConnectionUri = function (_a, params) {
            var projectId = _a.projectId, query = __rest(_a, ["projectId"]);
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/connection_uri"), method: 'GET', query: query, secure: true, format: 'json' }, params));
        };
        /**
         * @description Get the allow localhost configuration for the specified branch.
         *
         * @tags Auth
         * @name GetNeonAuthAllowLocalhost
         * @summary Get allow localhost
         * @request GET:/projects/{project_id}/branches/{branch_id}/auth/allow_localhost
         * @secure
         */
        _this.getNeonAuthAllowLocalhost = function (projectId, branchId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/auth/allow_localhost"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Updates the allow localhost configuration for the specified branch.
         *
         * @tags Auth
         * @name UpdateNeonAuthAllowLocalhost
         * @summary Update allow localhost
         * @request PATCH:/projects/{project_id}/branches/{branch_id}/auth/allow_localhost
         * @secure
         */
        _this.updateNeonAuthAllowLocalhost = function (projectId, branchId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/auth/allow_localhost"), method: 'PATCH', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Creates a branch in the specified project. You can obtain a `project_id` by listing the projects for your Neon account. This method does not require a request body, but you can specify one to create a compute endpoint for the branch or to select a non-default parent branch. By default, the branch is created from the project's default branch with no compute endpoint, and the branch name is auto-generated. To access the branch, you must add an endpoint object. A `read_write` endpoint allows you to perform read and write operations on the branch. Each branch supports one read-write endpoint and multiple read-only endpoints. For related information, see [Manage branches](https://neon.tech/docs/manage/branches/).
         *
         * @tags Branch
         * @name CreateProjectBranch
         * @summary Create branch
         * @request POST:/projects/{project_id}/branches
         * @secure
         */
        _this.createProjectBranch = function (projectId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches"), method: 'POST', body: data, secure: true, type: ContentType.Json }, params));
        };
        /**
         * @description Retrieves a list of branches for the specified project. You can obtain a `project_id` by listing the projects for your Neon account. Each Neon project has a root branch named `main`. A `branch_id` value has a `br-` prefix. A project may contain child branches that were branched from `main` or from another branch. A parent branch is identified by the `parent_id` value, which is the `id` of the parent branch. For related information, see [Manage branches](https://neon.tech/docs/manage/branches/).
         *
         * @tags Branch
         * @name ListProjectBranches
         * @summary List branches
         * @request GET:/projects/{project_id}/branches
         * @secure
         */
        _this.listProjectBranches = function (_a, params) {
            var projectId = _a.projectId, query = __rest(_a, ["projectId"]);
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches"), method: 'GET', query: query, secure: true, format: 'json' }, params));
        };
        /**
         * @description Creates a new branch with anonymized data using PostgreSQL Anonymizer for static masking. This allows developers to work with masked production data. Optionally, provide `masking_rules` to set initial masking rules for the branch and `start_anonymization` to automatically start anonymization after creation. This combines functionality of updating masking rules and starting anonymization into the branch creation request. **Note**: This endpoint is currently in Beta.
         *
         * @tags Branch
         * @name CreateProjectBranchAnonymized
         * @summary Create anonymized branch
         * @request POST:/projects/{project_id}/branch_anonymized
         * @secure
         */
        _this.createProjectBranchAnonymized = function (projectId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branch_anonymized"), method: 'POST', body: data, secure: true, type: ContentType.Json }, params));
        };
        /**
         * @description Retrieves the total number of branches in the specified project. You can obtain a `project_id` by listing the projects for your Neon account.
         *
         * @tags Branch
         * @name CountProjectBranches
         * @summary Retrieve number of branches
         * @request GET:/projects/{project_id}/branches/count
         * @secure
         */
        _this.countProjectBranches = function (_a, params) {
            var projectId = _a.projectId, query = __rest(_a, ["projectId"]);
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/count"), method: 'GET', query: query, secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves information about the specified branch. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain a `branch_id` by listing the project's branches. A `branch_id` value has a `br-` prefix. Each Neon project is initially created with a root and default branch named `main`. A project can contain one or more branches. A parent branch is identified by a `parent_id` value, which is the `id` of the parent branch. For related information, see [Manage branches](https://neon.tech/docs/manage/branches/).
         *
         * @tags Branch
         * @name GetProjectBranch
         * @summary Retrieve branch details
         * @request GET:/projects/{project_id}/branches/{branch_id}
         * @secure
         */
        _this.getProjectBranch = function (projectId, branchId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId)), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Deletes the specified branch from a project, and places all compute endpoints into an idle state, breaking existing client connections. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain a `branch_id` by listing the project's branches. For related information, see [Manage branches](https://neon.tech/docs/manage/branches/). When a successful response status is received, the compute endpoints are still active, and the branch is not yet deleted from storage. The deletion occurs after all operations finish. You cannot delete a project's root or default branch, and you cannot delete a branch that has a child branch. A project must have at least one branch.
         *
         * @tags Branch
         * @name DeleteProjectBranch
         * @summary Delete branch
         * @request DELETE:/projects/{project_id}/branches/{branch_id}
         * @secure
         */
        _this.deleteProjectBranch = function (projectId, branchId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId)), method: 'DELETE', secure: true, format: 'json' }, params));
        };
        /**
         * @description Updates the specified branch. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `branch_id` by listing the project's branches. For more information, see [Manage branches](https://neon.tech/docs/manage/branches/).
         *
         * @tags Branch
         * @name UpdateProjectBranch
         * @summary Update branch
         * @request PATCH:/projects/{project_id}/branches/{branch_id}
         * @secure
         */
        _this.updateProjectBranch = function (projectId, branchId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId)), method: 'PATCH', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Restores a branch to an earlier state in its own or another branch's history
         *
         * @tags Branch
         * @name RestoreProjectBranch
         * @summary Restore branch
         * @request POST:/projects/{project_id}/branches/{branch_id}/restore
         * @secure
         */
        _this.restoreProjectBranch = function (projectId, branchId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/restore"), method: 'POST', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Retrieves the schema from the specified database. The `lsn` and `timestamp` values cannot be specified at the same time. If both are omitted, the database schema is retrieved from database's head.
         *
         * @tags Branch
         * @name GetProjectBranchSchema
         * @summary Retrieve database schema
         * @request GET:/projects/{project_id}/branches/{branch_id}/schema
         * @secure
         */
        _this.getProjectBranchSchema = function (_a, params) {
            var projectId = _a.projectId, branchId = _a.branchId, query = __rest(_a, ["projectId", "branchId"]);
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/schema"), method: 'GET', query: query, secure: true, format: 'json' }, params));
        };
        /**
         * @description Compares the schema from the specified database with another branch's schema.
         *
         * @tags Branch
         * @name GetProjectBranchSchemaComparison
         * @summary Compare database schema
         * @request GET:/projects/{project_id}/branches/{branch_id}/compare_schema
         * @secure
         */
        _this.getProjectBranchSchemaComparison = function (_a, params) {
            var projectId = _a.projectId, branchId = _a.branchId, query = __rest(_a, ["projectId", "branchId"]);
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/compare_schema"), method: 'GET', query: query, secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves the masking rules for the specified anonymized branch. Masking rules define how sensitive data should be anonymized using PostgreSQL Anonymizer. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `branch_id` by listing the project's branches. **Note**: This endpoint is currently in Beta.
         *
         * @tags Branch
         * @name GetMaskingRules
         * @summary Get masking rules
         * @request GET:/projects/{project_id}/branches/{branch_id}/masking_rules
         * @secure
         */
        _this.getMaskingRules = function (projectId, branchId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/masking_rules"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Updates the masking rules for the specified anonymized branch. Masking rules define how sensitive data should be anonymized using PostgreSQL Anonymizer. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `branch_id` by listing the project's branches. **Note**: This endpoint is currently in Beta.
         *
         * @tags Branch
         * @name UpdateMaskingRules
         * @summary Update masking rules
         * @request PATCH:/projects/{project_id}/branches/{branch_id}/masking_rules
         * @secure
         */
        _this.updateMaskingRules = function (projectId, branchId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/masking_rules"), method: 'PATCH', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Retrieves the current status of an anonymized branch, including its state and progress information. This endpoint allows you to monitor the anonymization process from initialization through completion. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `branch_id` by listing the project's branches. Only anonymized branches will have status information available. **Note**: This endpoint is currently in Beta.
         *
         * @tags Branch
         * @name GetAnonymizedBranchStatus
         * @summary Get anonymized branch status
         * @request GET:/projects/{project_id}/branches/{branch_id}/anonymized_status
         * @secure
         */
        _this.getAnonymizedBranchStatus = function (projectId, branchId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/anonymized_status"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Starts the anonymization process for an anonymized branch that is in the initialized, error, or anonymized state. This will apply all defined masking rules to anonymize sensitive data in the branch databases. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `branch_id` by listing the project's branches. The branch must be an anonymized branch to start anonymization. **Note**: This endpoint is currently in Beta.
         *
         * @tags Branch
         * @name StartAnonymization
         * @summary Start anonymization
         * @request POST:/projects/{project_id}/branches/{branch_id}/anonymize
         * @secure
         */
        _this.startAnonymization = function (projectId, branchId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/anonymize"), method: 'POST', secure: true, format: 'json' }, params));
        };
        /**
         * @description Sets the specified branch as the project's default branch. The default designation is automatically removed from the previous default branch. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `branch_id` by listing the project's branches. For more information, see [Manage branches](https://neon.tech/docs/manage/branches/).
         *
         * @tags Branch
         * @name SetDefaultProjectBranch
         * @summary Set branch as default
         * @request POST:/projects/{project_id}/branches/{branch_id}/set_as_default
         * @secure
         */
        _this.setDefaultProjectBranch = function (projectId, branchId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/set_as_default"), method: 'POST', secure: true, format: 'json' }, params));
        };
        /**
         * @description Finalize the restore operation for a branch created from a snapshot. This operation updates the branch so it functions as the original branch it replaced. This includes: - Reassigning any computes from the original branch to the restored branch (this will restart the computes) - Renaming the restored branch to the original branch's name - Renaming the original branch so it no longer uses the original name This operation only applies to branches created using the `restoreSnapshot` endpoint with `finalize_restore: false`. **Note**: This endpoint is currently in Beta.
         *
         * @tags Branch
         * @name FinalizeRestoreBranch
         * @summary Finalize restore
         * @request POST:/projects/{project_id}/branches/{branch_id}/finalize_restore
         * @secure
         */
        _this.finalizeRestoreBranch = function (projectId, branchId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/finalize_restore"), method: 'POST', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Retrieves a list of compute endpoints for the specified branch. Neon permits only one read-write compute endpoint per branch. A branch can have multiple read-only compute endpoints. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `branch_id` by listing the project's branches.
         *
         * @tags Branch
         * @name ListProjectBranchEndpoints
         * @summary List branch endpoints
         * @request GET:/projects/{project_id}/branches/{branch_id}/endpoints
         * @secure
         */
        _this.listProjectBranchEndpoints = function (projectId, branchId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/endpoints"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves a list of databases for the specified branch. A branch can have multiple databases. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `branch_id` by listing the project's branches. For related information, see [Manage databases](https://neon.tech/docs/manage/databases/).
         *
         * @tags Branch
         * @name ListProjectBranchDatabases
         * @summary List databases
         * @request GET:/projects/{project_id}/branches/{branch_id}/databases
         * @secure
         */
        _this.listProjectBranchDatabases = function (projectId, branchId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/databases"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Creates a database in the specified branch. A branch can have multiple databases. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `branch_id` by listing the project's branches. For related information, see [Manage databases](https://neon.tech/docs/manage/databases/).
         *
         * @tags Branch
         * @name CreateProjectBranchDatabase
         * @summary Create database
         * @request POST:/projects/{project_id}/branches/{branch_id}/databases
         * @secure
         */
        _this.createProjectBranchDatabase = function (projectId, branchId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/databases"), method: 'POST', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Retrieves information about the specified database. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `branch_id` and `database_name` by listing the branch's databases. For related information, see [Manage databases](https://neon.tech/docs/manage/databases/).
         *
         * @tags Branch
         * @name GetProjectBranchDatabase
         * @summary Retrieve database details
         * @request GET:/projects/{project_id}/branches/{branch_id}/databases/{database_name}
         * @secure
         */
        _this.getProjectBranchDatabase = function (projectId, branchId, databaseName, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/databases/").concat(encodeURIComponent(databaseName)), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Updates the specified database in the branch. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `branch_id` and `database_name` by listing the branch's databases. For related information, see [Manage databases](https://neon.tech/docs/manage/databases/).
         *
         * @tags Branch
         * @name UpdateProjectBranchDatabase
         * @summary Update database
         * @request PATCH:/projects/{project_id}/branches/{branch_id}/databases/{database_name}
         * @secure
         */
        _this.updateProjectBranchDatabase = function (projectId, branchId, databaseName, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/databases/").concat(encodeURIComponent(databaseName)), method: 'PATCH', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Deletes the specified database from the branch. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `branch_id` and `database_name` by listing the branch's databases. For related information, see [Manage databases](https://neon.tech/docs/manage/databases/).
         *
         * @tags Branch
         * @name DeleteProjectBranchDatabase
         * @summary Delete database
         * @request DELETE:/projects/{project_id}/branches/{branch_id}/databases/{database_name}
         * @secure
         */
        _this.deleteProjectBranchDatabase = function (projectId, branchId, databaseName, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/databases/").concat(encodeURIComponent(databaseName)), method: 'DELETE', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves a list of Postgres roles from the specified branch. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `branch_id` by listing the project's branches. For related information, see [Manage roles](https://neon.tech/docs/manage/roles/).
         *
         * @tags Branch
         * @name ListProjectBranchRoles
         * @summary List roles
         * @request GET:/projects/{project_id}/branches/{branch_id}/roles
         * @secure
         */
        _this.listProjectBranchRoles = function (projectId, branchId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/roles"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Creates a Postgres role in the specified branch. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `branch_id` by listing the project's branches. For related information, see [Manage roles](https://neon.tech/docs/manage/roles/). Connections established to the active compute endpoint will be dropped. If the compute endpoint is idle, the endpoint becomes active for a short period of time and is suspended afterward.
         *
         * @tags Branch
         * @name CreateProjectBranchRole
         * @summary Create role
         * @request POST:/projects/{project_id}/branches/{branch_id}/roles
         * @secure
         */
        _this.createProjectBranchRole = function (projectId, branchId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/roles"), method: 'POST', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Retrieves details about the specified role. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `branch_id` by listing the project's branches. You can obtain the `role_name` by listing the roles for a branch. In Neon, the terms "role" and "user" are synonymous. For related information, see [Manage roles](https://neon.tech/docs/manage/roles/).
         *
         * @tags Branch
         * @name GetProjectBranchRole
         * @summary Retrieve role details
         * @request GET:/projects/{project_id}/branches/{branch_id}/roles/{role_name}
         * @secure
         */
        _this.getProjectBranchRole = function (projectId, branchId, roleName, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/roles/").concat(encodeURIComponent(roleName)), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Deletes the specified Postgres role from the branch. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `branch_id` by listing the project's branches. You can obtain the `role_name` by listing the roles for a branch. For related information, see [Manage roles](https://neon.tech/docs/manage/roles/).
         *
         * @tags Branch
         * @name DeleteProjectBranchRole
         * @summary Delete role
         * @request DELETE:/projects/{project_id}/branches/{branch_id}/roles/{role_name}
         * @secure
         */
        _this.deleteProjectBranchRole = function (projectId, branchId, roleName, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/roles/").concat(encodeURIComponent(roleName)), method: 'DELETE', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves the password for the specified Postgres role, if possible. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `branch_id` by listing the project's branches. You can obtain the `role_name` by listing the roles for a branch. For related information, see [Manage roles](https://neon.tech/docs/manage/roles/).
         *
         * @tags Branch
         * @name GetProjectBranchRolePassword
         * @summary Retrieve role password
         * @request GET:/projects/{project_id}/branches/{branch_id}/roles/{role_name}/reveal_password
         * @secure
         */
        _this.getProjectBranchRolePassword = function (projectId, branchId, roleName, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/roles/").concat(encodeURIComponent(roleName), "/reveal_password"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Resets the password for the specified Postgres role. Returns a new password and operations. The new password is ready to use when the last operation finishes. The old password remains valid until last operation finishes. Connections to the compute endpoint are dropped. If idle, the compute endpoint becomes active for a short period of time. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain the `branch_id` by listing the project's branches. You can obtain the `role_name` by listing the roles for a branch. For related information, see [Manage roles](https://neon.tech/docs/manage/roles/).
         *
         * @tags Branch
         * @name ResetProjectBranchRolePassword
         * @summary Reset role password
         * @request POST:/projects/{project_id}/branches/{branch_id}/roles/{role_name}/reset_password
         * @secure
         */
        _this.resetProjectBranchRolePassword = function (projectId, branchId, roleName, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/roles/").concat(encodeURIComponent(roleName), "/reset_password"), method: 'POST', secure: true, format: 'json' }, params));
        };
        /**
         * @description Lists VPC endpoint restrictions for the specified Neon project.
         *
         * @tags Project
         * @name ListProjectVpcEndpoints
         * @summary List VPC endpoint restrictions
         * @request GET:/projects/{project_id}/vpc_endpoints
         * @secure
         */
        _this.listProjectVpcEndpoints = function (projectId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/vpc_endpoints"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Sets or updates a VPC endpoint restriction for a Neon project. When a VPC endpoint restriction is set, the project only accepts connections from the specified VPC. A VPC endpoint can be set as a restriction only after it is assigned to the parent organization of the Neon project.
         *
         * @tags Project
         * @name AssignProjectVpcEndpoint
         * @summary Set VPC endpoint restriction
         * @request POST:/projects/{project_id}/vpc_endpoints/{vpc_endpoint_id}
         * @secure
         */
        _this.assignProjectVpcEndpoint = function (projectId, vpcEndpointId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/vpc_endpoints/").concat(encodeURIComponent(vpcEndpointId)), method: 'POST', body: data, secure: true, type: ContentType.Json }, params));
        };
        /**
         * @description Removes the specified VPC endpoint restriction from a Neon project.
         *
         * @tags Project
         * @name DeleteProjectVpcEndpoint
         * @summary Delete VPC endpoint restriction
         * @request DELETE:/projects/{project_id}/vpc_endpoints/{vpc_endpoint_id}
         * @secure
         */
        _this.deleteProjectVpcEndpoint = function (projectId, vpcEndpointId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/vpc_endpoints/").concat(encodeURIComponent(vpcEndpointId)), method: 'DELETE', secure: true }, params));
        };
        /**
         * @description Creates a compute endpoint for the specified branch. An endpoint is a Neon compute instance. There is a maximum of one read-write compute endpoint per branch. If the specified branch already has a read-write compute endpoint, the operation fails. A branch can have multiple read-only compute endpoints. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain `branch_id` by listing the project's branches. A `branch_id` has a `br-` prefix. For supported regions and `region_id` values, see [Regions](https://neon.tech/docs/introduction/regions/). For more information about compute endpoints, see [Manage computes](https://neon.tech/docs/manage/endpoints/).
         *
         * @tags Endpoint
         * @name CreateProjectEndpoint
         * @summary Create compute endpoint
         * @request POST:/projects/{project_id}/endpoints
         * @secure
         */
        _this.createProjectEndpoint = function (projectId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/endpoints"), method: 'POST', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Retrieves a list of compute endpoints for the specified project. A compute endpoint is a Neon compute instance. You can obtain a `project_id` by listing the projects for your Neon account. For information about compute endpoints, see [Manage computes](https://neon.tech/docs/manage/endpoints/).
         *
         * @tags Endpoint
         * @name ListProjectEndpoints
         * @summary List compute endpoints
         * @request GET:/projects/{project_id}/endpoints
         * @secure
         */
        _this.listProjectEndpoints = function (projectId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/endpoints"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves information about the specified compute endpoint. A compute endpoint is a Neon compute instance. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain an `endpoint_id` by listing your project's compute endpoints. An `endpoint_id` has an `ep-` prefix. For information about compute endpoints, see [Manage computes](https://neon.tech/docs/manage/endpoints/).
         *
         * @tags Endpoint
         * @name GetProjectEndpoint
         * @summary Retrieve compute endpoint details
         * @request GET:/projects/{project_id}/endpoints/{endpoint_id}
         * @secure
         */
        _this.getProjectEndpoint = function (projectId, endpointId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/endpoints/").concat(encodeURIComponent(endpointId)), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Delete the specified compute endpoint. A compute endpoint is a Neon compute instance. Deleting a compute endpoint drops existing network connections to the compute endpoint. The deletion is completed when last operation in the chain finishes successfully. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain an `endpoint_id` by listing your project's compute endpoints. An `endpoint_id` has an `ep-` prefix. For information about compute endpoints, see [Manage computes](https://neon.tech/docs/manage/endpoints/).
         *
         * @tags Endpoint
         * @name DeleteProjectEndpoint
         * @summary Delete compute endpoint
         * @request DELETE:/projects/{project_id}/endpoints/{endpoint_id}
         * @secure
         */
        _this.deleteProjectEndpoint = function (projectId, endpointId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/endpoints/").concat(encodeURIComponent(endpointId)), method: 'DELETE', secure: true, format: 'json' }, params));
        };
        /**
         * @description Updates the specified compute endpoint. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain an `endpoint_id` and `branch_id` by listing your project's compute endpoints. An `endpoint_id` has an `ep-` prefix. A `branch_id` has a `br-` prefix. For more information about compute endpoints, see [Manage computes](https://neon.tech/docs/manage/endpoints/). If the returned list of operations is not empty, the compute endpoint is not ready to use. The client must wait for the last operation to finish before using the compute endpoint. If the compute endpoint was idle before the update, it becomes active for a short period of time, and the control plane suspends it again after the update.
         *
         * @tags Endpoint
         * @name UpdateProjectEndpoint
         * @summary Update compute endpoint
         * @request PATCH:/projects/{project_id}/endpoints/{endpoint_id}
         * @secure
         */
        _this.updateProjectEndpoint = function (projectId, endpointId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/endpoints/").concat(encodeURIComponent(endpointId)), method: 'PATCH', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Starts a compute endpoint. The compute endpoint is ready to use after the last operation in chain finishes successfully. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain an `endpoint_id` by listing your project's compute endpoints. An `endpoint_id` has an `ep-` prefix. For information about compute endpoints, see [Manage computes](https://neon.tech/docs/manage/endpoints/).
         *
         * @tags Endpoint
         * @name StartProjectEndpoint
         * @summary Start compute endpoint
         * @request POST:/projects/{project_id}/endpoints/{endpoint_id}/start
         * @secure
         */
        _this.startProjectEndpoint = function (projectId, endpointId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/endpoints/").concat(encodeURIComponent(endpointId), "/start"), method: 'POST', secure: true, format: 'json' }, params));
        };
        /**
         * @description Suspend the specified compute endpoint You can obtain a `project_id` by listing the projects for your Neon account. You can obtain an `endpoint_id` by listing your project's compute endpoints. An `endpoint_id` has an `ep-` prefix. For information about compute endpoints, see [Manage computes](https://neon.tech/docs/manage/endpoints/).
         *
         * @tags Endpoint
         * @name SuspendProjectEndpoint
         * @summary Suspend compute endpoint
         * @request POST:/projects/{project_id}/endpoints/{endpoint_id}/suspend
         * @secure
         */
        _this.suspendProjectEndpoint = function (projectId, endpointId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/endpoints/").concat(encodeURIComponent(endpointId), "/suspend"), method: 'POST', secure: true, format: 'json' }, params));
        };
        /**
         * @description Restart the specified compute endpoint: suspend immediately followed by start operations. You can obtain a `project_id` by listing the projects for your Neon account. You can obtain an `endpoint_id` by listing your project's compute endpoints. An `endpoint_id` has an `ep-` prefix. For information about compute endpoints, see [Manage computes](https://neon.tech/docs/manage/endpoints/).
         *
         * @tags Endpoint
         * @name RestartProjectEndpoint
         * @summary Restart compute endpoint
         * @request POST:/projects/{project_id}/endpoints/{endpoint_id}/restart
         * @secure
         */
        _this.restartProjectEndpoint = function (projectId, endpointId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/endpoints/").concat(encodeURIComponent(endpointId), "/restart"), method: 'POST', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves consumption metrics for Scale and Enterprise plan accounts, and for legacy Scale, Business, and Enterprise plan accounts. Consumption history begins at the time the account was upgraded to a supported plan.
         *
         * @tags Consumption
         * @name GetConsumptionHistoryPerAccount
         * @summary Retrieve account consumption metrics
         * @request GET:/consumption_history/account
         * @secure
         */
        _this.getConsumptionHistoryPerAccount = function (query, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/consumption_history/account", method: 'GET', query: query, secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves consumption metrics for Scale, Business, and Enterprise plan projects. History begins at the time of upgrade. Issuing a call to this API does not wake a project's compute endpoint.
         *
         * @tags Consumption
         * @name GetConsumptionHistoryPerProject
         * @summary Retrieve project consumption metrics
         * @request GET:/consumption_history/projects
         * @secure
         */
        _this.getConsumptionHistoryPerProject = function (query, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/consumption_history/projects", method: 'GET', query: query, secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves information about the specified organization.
         *
         * @tags Organizations
         * @name GetOrganization
         * @summary Retrieve organization details
         * @request GET:/organizations/{org_id}
         * @secure
         */
        _this.getOrganization = function (orgId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/organizations/".concat(encodeURIComponent(orgId)), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves the API keys for the specified organization. The response does not include API key tokens. A token is only provided when creating an API key. API keys can also be managed in the Neon Console. For more information, see [Manage API keys](https://neon.tech/docs/manage/api-keys/).
         *
         * @tags Organizations
         * @name ListOrgApiKeys
         * @summary List organization API keys
         * @request GET:/organizations/{org_id}/api_keys
         * @secure
         */
        _this.listOrgApiKeys = function (orgId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/organizations/".concat(encodeURIComponent(orgId), "/api_keys"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Creates an API key for the specified organization. The `key_name` is a user-specified name for the key. This method returns an `id` and `key`. The `key` is a randomly generated, 64-bit token required to access the Neon API. API keys can also be managed in the Neon Console. See [Manage API keys](https://neon.tech/docs/manage/api-keys/).
         *
         * @tags Organizations
         * @name CreateOrgApiKey
         * @summary Create organization API key
         * @request POST:/organizations/{org_id}/api_keys
         * @secure
         */
        _this.createOrgApiKey = function (orgId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/organizations/".concat(encodeURIComponent(orgId), "/api_keys"), method: 'POST', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Revokes the specified organization API key. An API key that is no longer needed can be revoked. This action cannot be reversed. You can obtain `key_id` values by listing the API keys for an organization. API keys can also be managed in the Neon Console. See [Manage API keys](https://neon.tech/docs/manage/api-keys/).
         *
         * @tags Organizations
         * @name RevokeOrgApiKey
         * @summary Revoke organization API key
         * @request DELETE:/organizations/{org_id}/api_keys/{key_id}
         * @secure
         */
        _this.revokeOrgApiKey = function (orgId, keyId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/organizations/".concat(encodeURIComponent(orgId), "/api_keys/").concat(encodeURIComponent(keyId)), method: 'DELETE', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves information about the specified organization members.
         *
         * @tags Organizations
         * @name GetOrganizationMembers
         * @summary Retrieve organization members details
         * @request GET:/organizations/{org_id}/members
         * @secure
         */
        _this.getOrganizationMembers = function (orgId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/organizations/".concat(encodeURIComponent(orgId), "/members"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves information about the specified organization member.
         *
         * @tags Organizations
         * @name GetOrganizationMember
         * @summary Retrieve organization member details
         * @request GET:/organizations/{org_id}/members/{member_id}
         * @secure
         */
        _this.getOrganizationMember = function (orgId, memberId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/organizations/".concat(encodeURIComponent(orgId), "/members/").concat(encodeURIComponent(memberId)), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Only an admin can perform this action.
         *
         * @tags Organizations
         * @name UpdateOrganizationMember
         * @summary Update role for organization member
         * @request PATCH:/organizations/{org_id}/members/{member_id}
         * @secure
         */
        _this.updateOrganizationMember = function (orgId, memberId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/organizations/".concat(encodeURIComponent(orgId), "/members/").concat(encodeURIComponent(memberId)), method: 'PATCH', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Remove member from the organization. Only an admin of the organization can perform this action. If another admin is being removed, it will not be allows in case it is the only admin left in the organization.
         *
         * @tags Organizations
         * @name RemoveOrganizationMember
         * @summary Remove member from the organization
         * @request DELETE:/organizations/{org_id}/members/{member_id}
         * @secure
         */
        _this.removeOrganizationMember = function (orgId, memberId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/organizations/".concat(encodeURIComponent(orgId), "/members/").concat(encodeURIComponent(memberId)), method: 'DELETE', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves information about extended invitations for the specified organization
         *
         * @tags Organizations
         * @name GetOrganizationInvitations
         * @summary Retrieve organization invitation details
         * @request GET:/organizations/{org_id}/invitations
         * @secure
         */
        _this.getOrganizationInvitations = function (orgId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/organizations/".concat(encodeURIComponent(orgId), "/invitations"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Creates invitations for a specific organization. If the invited user has an existing account, they automatically join as a member. If they don't yet have an account, they are invited to create one, after which they become a member. Each invited user receives an email notification.
         *
         * @tags Organizations
         * @name CreateOrganizationInvitations
         * @summary Create organization invitations
         * @request POST:/organizations/{org_id}/invitations
         * @secure
         */
        _this.createOrganizationInvitations = function (orgId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/organizations/".concat(encodeURIComponent(orgId), "/invitations"), method: 'POST', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Transfers selected projects, identified by their IDs, from your organization to another specified organization.
         *
         * @tags Organizations
         * @name TransferProjectsFromOrgToOrg
         * @summary Transfer projects between organizations
         * @request POST:/organizations/{source_org_id}/projects/transfer
         * @secure
         */
        _this.transferProjectsFromOrgToOrg = function (sourceOrgId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/organizations/".concat(encodeURIComponent(sourceOrgId), "/projects/transfer"), method: 'POST', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Retrieves the list of VPC endpoints for the specified Neon organization across all regions.
         *
         * @tags Organizations
         * @name ListOrganizationVpcEndpointsAllRegions
         * @summary List VPC endpoints across all regions
         * @request GET:/organizations/{org_id}/vpc/vpc_endpoints
         * @secure
         */
        _this.listOrganizationVpcEndpointsAllRegions = function (orgId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/organizations/".concat(encodeURIComponent(orgId), "/vpc/vpc_endpoints"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves the list of VPC endpoints for the specified Neon organization.
         *
         * @tags Organizations
         * @name ListOrganizationVpcEndpoints
         * @summary List VPC endpoints
         * @request GET:/organizations/{org_id}/vpc/region/{region_id}/vpc_endpoints
         * @secure
         */
        _this.listOrganizationVpcEndpoints = function (orgId, regionId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/organizations/".concat(encodeURIComponent(orgId), "/vpc/region/").concat(encodeURIComponent(regionId), "/vpc_endpoints"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves the current state and configuration details of a specified VPC endpoint.
         *
         * @tags Organizations
         * @name GetOrganizationVpcEndpointDetails
         * @summary Retrieve VPC endpoint details
         * @request GET:/organizations/{org_id}/vpc/region/{region_id}/vpc_endpoints/{vpc_endpoint_id}
         * @secure
         */
        _this.getOrganizationVpcEndpointDetails = function (orgId, regionId, vpcEndpointId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/organizations/".concat(encodeURIComponent(orgId), "/vpc/region/").concat(encodeURIComponent(regionId), "/vpc_endpoints/").concat(encodeURIComponent(vpcEndpointId)), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Assigns a VPC endpoint to a Neon organization or updates its existing assignment.
         *
         * @tags Organizations
         * @name AssignOrganizationVpcEndpoint
         * @summary Assign or update VPC endpoint
         * @request POST:/organizations/{org_id}/vpc/region/{region_id}/vpc_endpoints/{vpc_endpoint_id}
         * @secure
         */
        _this.assignOrganizationVpcEndpoint = function (orgId, regionId, vpcEndpointId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/organizations/".concat(encodeURIComponent(orgId), "/vpc/region/").concat(encodeURIComponent(regionId), "/vpc_endpoints/").concat(encodeURIComponent(vpcEndpointId)), method: 'POST', body: data, secure: true, type: ContentType.Json }, params));
        };
        /**
         * @description Deletes the VPC endpoint from the specified Neon organization. If you delete a VPC endpoint from a Neon organization, that VPC endpoint cannot be added back to the Neon organization.
         *
         * @tags Organizations
         * @name DeleteOrganizationVpcEndpoint
         * @summary Delete VPC endpoint
         * @request DELETE:/organizations/{org_id}/vpc/region/{region_id}/vpc_endpoints/{vpc_endpoint_id}
         * @secure
         */
        _this.deleteOrganizationVpcEndpoint = function (orgId, regionId, vpcEndpointId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/organizations/".concat(encodeURIComponent(orgId), "/vpc/region/").concat(encodeURIComponent(regionId), "/vpc_endpoints/").concat(encodeURIComponent(vpcEndpointId)), method: 'DELETE', secure: true }, params));
        };
        /**
         * @description Lists supported Neon regions
         *
         * @tags Region
         * @name GetActiveRegions
         * @summary List supported regions
         * @request GET:/regions
         * @secure
         */
        _this.getActiveRegions = function (params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/regions", method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves information about the current Neon user account.
         *
         * @tags Users
         * @name GetCurrentUserInfo
         * @summary Retrieve current user details
         * @request GET:/users/me
         * @secure
         */
        _this.getCurrentUserInfo = function (params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/users/me", method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Retrieves information about the current Neon user's organizations
         *
         * @tags Users, Organizations
         * @name GetCurrentUserOrganizations
         * @summary Retrieve current user organizations list
         * @request GET:/users/me/organizations
         * @secure
         */
        _this.getCurrentUserOrganizations = function (params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/users/me/organizations", method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Transfers selected projects, identified by their IDs, from your personal account to a specified organization.
         *
         * @tags Users
         * @name TransferProjectsFromUserToOrg
         * @summary Transfer projects from personal account to organization
         * @request POST:/users/me/projects/transfer
         * @secure
         */
        _this.transferProjectsFromUserToOrg = function (data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/users/me/projects/transfer", method: 'POST', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Returns auth information about the passed credentials. It can refer to an API key, Bearer token or OAuth session.
         *
         * @tags Users
         * @name GetAuthDetails
         * @summary Get request authentication details
         * @request GET:/auth
         * @secure
         */
        _this.getAuthDetails = function (params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/auth", method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Create a snapshot from the specified branch using the provided parameters. This endpoint may initiate an asynchronous operation. **Note**: This endpoint is currently in Beta.
         *
         * @tags Snapshot
         * @name CreateSnapshot
         * @summary Create snapshot
         * @request POST:/projects/{project_id}/branches/{branch_id}/snapshot
         * @secure
         */
        _this.createSnapshot = function (_a, params) {
            var projectId = _a.projectId, branchId = _a.branchId, query = __rest(_a, ["projectId", "branchId"]);
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/snapshot"), method: 'POST', query: query, secure: true, format: 'json' }, params));
        };
        /**
         * @description List the snapshots for the specified project. **Note**: This endpoint is currently in Beta.
         *
         * @tags Snapshot
         * @name ListSnapshots
         * @summary List project snapshots
         * @request GET:/projects/{project_id}/snapshots
         * @secure
         */
        _this.listSnapshots = function (projectId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/snapshots"), method: 'GET', secure: true, format: 'json' }, params));
        };
        /**
         * @description Delete the specified snapshot. **Note**: This endpoint is currently in Beta.
         *
         * @tags Snapshot
         * @name DeleteSnapshot
         * @summary Delete snapshot
         * @request DELETE:/projects/{project_id}/snapshots/{snapshot_id}
         * @secure
         */
        _this.deleteSnapshot = function (projectId, snapshotId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/snapshots/").concat(encodeURIComponent(snapshotId)), method: 'DELETE', secure: true, format: 'json' }, params));
        };
        /**
         * @description Update the specified snapshot. **Note**: This endpoint is currently in Beta.
         *
         * @tags Snapshot
         * @name UpdateSnapshot
         * @summary Update snapshot
         * @request PATCH:/projects/{project_id}/snapshots/{snapshot_id}
         * @secure
         */
        _this.updateSnapshot = function (projectId, snapshotId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/snapshots/").concat(encodeURIComponent(snapshotId)), method: 'PATCH', body: data, secure: true, type: ContentType.Json, format: 'json' }, params));
        };
        /**
         * @description Restore the specified snapshot to a new branch and optionally finalize the restore operation. **Note**: This endpoint is currently in Beta.
         *
         * @tags Snapshot
         * @name RestoreSnapshot
         * @summary Restore snapshot
         * @request POST:/projects/{project_id}/snapshots/{snapshot_id}/restore
         * @secure
         */
        _this.restoreSnapshot = function (_a, data, params) {
            var projectId = _a.projectId, snapshotId = _a.snapshotId, query = __rest(_a, ["projectId", "snapshotId"]);
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/snapshots/").concat(encodeURIComponent(snapshotId), "/restore"), method: 'POST', query: query, body: data, secure: true, type: ContentType.Json }, params));
        };
        /**
         * @description View the backup schedule for the specified branch. **Note**: This endpoint is currently in Beta.
         *
         * @tags Snapshot
         * @name GetSnapshotSchedule
         * @summary View backup schedule
         * @request GET:/projects/{project_id}/branches/{branch_id}/backup_schedule
         * @secure
         */
        _this.getSnapshotSchedule = function (projectId, branchId, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/backup_schedule"), method: 'GET', secure: true }, params));
        };
        /**
         * @description Update the backup schedule for the specified branch. **Note** : This endpoint is currently in Beta.
         *
         * @tags Snapshot
         * @name SetSnapshotSchedule
         * @summary Update backup schedule
         * @request PUT:/projects/{project_id}/branches/{branch_id}/backup_schedule
         * @secure
         */
        _this.setSnapshotSchedule = function (projectId, branchId, data, params) {
            if (params === void 0) { params = {}; }
            return _this.request(__assign({ path: "/projects/".concat(encodeURIComponent(projectId), "/branches/").concat(encodeURIComponent(branchId), "/backup_schedule"), method: 'PUT', body: data, secure: true, type: ContentType.Json }, params));
        };
        return _this;
    }
    return Api;
}(HttpClient));
exports.Api = Api;
