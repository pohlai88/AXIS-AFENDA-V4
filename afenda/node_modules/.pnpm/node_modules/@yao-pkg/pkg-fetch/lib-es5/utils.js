"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.nodeBinarySortFunction = exports.spawn = exports.plusx = exports.hash = exports.downloadUrl = void 0;
const node_fetch_1 = __importDefault(require("node-fetch"));
const crypto_1 = __importDefault(require("crypto"));
const fs_1 = require("fs");
const promises_1 = require("fs/promises");
const https_proxy_agent_1 = __importDefault(require("https-proxy-agent"));
const path_1 = __importDefault(require("path"));
const child_process_1 = require("child_process");
const stream_1 = __importDefault(require("stream"));
const semver_1 = require("semver");
const log_1 = require("./log");
async function downloadUrl(url, file) {
    log_1.log.enableProgress(path_1.default.basename(file));
    log_1.log.showProgress(0);
    const proxy = process.env.HTTPS_PROXY ??
        process.env.https_proxy ??
        process.env.HTTP_PROXY ??
        process.env.http_proxy;
    let res;
    try {
        res = await (0, node_fetch_1.default)(url, proxy ? { agent: (0, https_proxy_agent_1.default)(proxy) } : undefined);
    }
    catch (err) {
        log_1.log.disableProgress();
        throw (0, log_1.wasReported)(`Network error during fetch: ${err.message}`);
    }
    if (!res.ok) {
        log_1.log.disableProgress();
        throw (0, log_1.wasReported)(`${res.status}: ${res.statusText}`);
    }
    const tempFile = `${file}.downloading`;
    (0, fs_1.mkdirSync)(path_1.default.dirname(tempFile), { recursive: true });
    const ws = (0, fs_1.createWriteStream)(tempFile);
    const totalSize = Number(res.headers.get('content-length'));
    let currentSize = 0;
    res.body.on('data', (chunk) => {
        if (totalSize != null && totalSize !== 0) {
            currentSize += chunk.length;
            log_1.log.showProgress((currentSize / totalSize) * 100);
        }
    });
    res.body.pipe(ws);
    return new Promise((resolve, reject) => {
        stream_1.default.finished(ws, (err) => {
            if (err) {
                log_1.log.disableProgress();
                (0, fs_1.rmSync)(tempFile);
                reject((0, log_1.wasReported)(`${err.name}: ${err.message}`));
            }
            else {
                log_1.log.showProgress(100);
                log_1.log.disableProgress();
                (0, fs_1.renameSync)(tempFile, file);
                resolve();
            }
        });
    });
}
exports.downloadUrl = downloadUrl;
async function hash(filePath) {
    return new Promise((resolve, reject) => {
        const resultHash = crypto_1.default.createHash('sha256');
        const input = (0, fs_1.createReadStream)(filePath);
        input.on('error', (e) => {
            reject(e);
        });
        input.on('readable', () => {
            const data = input.read();
            if (data) {
                resultHash.update(data);
            }
            else {
                resolve(resultHash.digest('hex'));
            }
        });
    });
}
exports.hash = hash;
async function plusx(file) {
    const s = await (0, promises_1.stat)(file);
    const newMode = s.mode | 64 | 8 | 1;
    if (s.mode === newMode)
        return;
    const base8 = newMode.toString(8).slice(-3);
    await (0, promises_1.chmod)(file, base8);
}
exports.plusx = plusx;
async function spawn(command, args, options) {
    const { error } = (0, child_process_1.spawnSync)(command, args, options);
    if (error) {
        throw error;
    }
}
exports.spawn = spawn;
function nodeBinarySortFunction(a, b) {
    const coercedVersionA = (0, semver_1.coerce)(a);
    const coercedVersionB = (0, semver_1.coerce)(b);
    if (coercedVersionA && coercedVersionB) {
        return coercedVersionA.compare(coercedVersionB);
    }
    return 0;
}
exports.nodeBinarySortFunction = nodeBinarySortFunction;
//# sourceMappingURL=utils.js.map