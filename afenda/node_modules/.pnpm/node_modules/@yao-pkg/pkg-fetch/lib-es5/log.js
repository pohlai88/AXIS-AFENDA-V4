"use strict";
/* eslint-disable no-underscore-dangle, no-console */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.wasReported = exports.log = void 0;
const progress_1 = __importDefault(require("progress"));
const assert_1 = __importDefault(require("assert"));
const picocolors_1 = __importDefault(require("picocolors"));
const tty_1 = require("tty");
// workaround until picocolors improves its color detection
// https://github.com/alexeyraspopov/picocolors/issues/85
const pc = picocolors_1.default.createColors(tty_1.WriteStream.prototype.hasColors());
class Log {
    debugMode = false;
    bar;
    lines(lines) {
        if (lines === undefined) {
            return;
        }
        if (!Array.isArray(lines)) {
            console.log(`  ${lines}`);
            return;
        }
        for (const line of lines) {
            console.log(`  ${line}`);
        }
    }
    debug(text, lines) {
        if (!this.debugMode) {
            return;
        }
        console.log(`> ${pc.green('[debug]')} ${text}`);
        this.lines(lines);
    }
    info(text, lines) {
        console.log(`> ${text}`);
        this.lines(lines);
    }
    warn(text, lines) {
        console.log(`> ${pc.blue('Warning')} ${text}`);
        this.lines(lines);
    }
    error(text, lines) {
        const message = text instanceof Error ? text.stack : text;
        console.log(`> ${pc.red('Error!')} ${message}`);
        this.lines(lines);
    }
    enableProgress(text) {
        (0, assert_1.default)(!this.bar);
        text += ' '.repeat(35 - text.length);
        this.bar = new progress_1.default(`  ${text} [:bar] :percent`, {
            stream: process.stdout,
            width: 20,
            complete: '=',
            incomplete: ' ',
            total: 100,
        });
    }
    showProgress(percentage) {
        if (!this.bar) {
            return;
        }
        this.bar.update(percentage / 100);
    }
    disableProgress() {
        if (!this.bar) {
            return;
        }
        // avoid empty line
        if (!this.bar.complete) {
            this.bar.terminate();
        }
        delete this.bar;
    }
}
exports.log = new Log();
class ReportedError extends Error {
    name = 'ReportedError';
    wasReported = true;
}
function wasReported(error, lines) {
    let reportedError = new ReportedError('No message');
    if (typeof error === 'string') {
        exports.log.error(error, lines);
        reportedError = new ReportedError(error);
    }
    return reportedError;
}
exports.wasReported = wasReported;
//# sourceMappingURL=log.js.map