import { configureExtension, installExtension, usesExtension, waitForExtensionInstalled } from "./extension.js";
import { createApiKeyFromNeonctl, ensureNeonctlAuth } from "./auth.js";
import { getMCPConfig, writeMCPConfig } from "./mcp-config.js";
import { confirm, isCancel, log, spinner } from "@clack/prompts";

//#region src/lib/install.ts
/**
* Checks if an editor needs MCP configuration
* Returns true if configuration is needed, false otherwise
*/
async function shouldConfigureMCP(homeDir, workspaceDir, editor) {
	const { config } = getMCPConfig(homeDir, workspaceDir, editor);
	const serverKey = editor === "VS Code" ? config.servers : config.mcpServers;
	if (Boolean(serverKey?.Neon)) {
		const response = await confirm({
			message: `Neon MCP Server is already configured for ${editor}. Would you like to reconfigure it? (Y/n)`,
			initialValue: true
		});
		if (isCancel(response)) return false;
		if (!response) {
			log.info(`Keeping existing MCP server configuration for ${editor}.`);
			return false;
		}
	}
	return true;
}
/**
* Installs Neon's MCP Server for specific editors
*/
async function installMCPServerForEditor(homeDir, workspaceDir, editor, apiKey) {
	const { config, configPath } = getMCPConfig(homeDir, workspaceDir, editor);
	const neonServerConfig = {
		type: "http",
		url: "https://mcp.neon.tech/mcp",
		headers: { Authorization: `Bearer ${apiKey}` }
	};
	if (!config.mcpServers) config.mcpServers = {};
	config.mcpServers.Neon = neonServerConfig;
	try {
		writeMCPConfig(configPath, config);
		return "success";
	} catch (error) {
		log.error(`Failed to write configuration for ${editor}: ${error instanceof Error ? error.message : "Unknown error"}`);
		return "failed";
	}
}
/**
* Installs Neon's Local Connect extension or MCP Server for specific editors
*/
async function installNeon(homeDir, workspaceDir, selectedEditors) {
	const results = /* @__PURE__ */ new Map();
	const extensionEditors = selectedEditors.filter(usesExtension);
	const mcpEditors = selectedEditors.filter((e) => !usesExtension(e));
	const mcpEditorsToConfigureMap = /* @__PURE__ */ new Map();
	for (const editor of mcpEditors) {
		const needsConfig = await shouldConfigureMCP(homeDir, workspaceDir, editor);
		mcpEditorsToConfigureMap.set(editor, needsConfig);
		if (!needsConfig) results.set(editor, "success");
	}
	const mcpToConfigure = mcpEditors.filter((editor) => mcpEditorsToConfigureMap.get(editor) === true);
	const extensionsToConfigure = extensionEditors;
	if (extensionsToConfigure.length === 0 && mcpToConfigure.length === 0) return results;
	const authSpinner = spinner();
	authSpinner.start("Authenticating...");
	if (!await ensureNeonctlAuth()) {
		authSpinner.stop("Authentication failed");
		for (const editor of [...extensionsToConfigure, ...mcpToConfigure]) results.set(editor, "failed");
		return results;
	}
	authSpinner.stop("Authentication successful âœ“");
	const apiKey = await createApiKeyFromNeonctl();
	if (!apiKey) {
		log.error("Could not create API key after authentication.");
		log.info("You can manually create one at: https://console.neon.tech/app/settings/api-keys");
		for (const editor of [...extensionsToConfigure, ...mcpToConfigure]) results.set(editor, "failed");
		return results;
	}
	for (const editor of extensionsToConfigure) {
		if (!await installExtension(editor)) {
			results.set(editor, "failed");
			continue;
		}
		if (!await waitForExtensionInstalled(editor)) {
			results.set(editor, "failed");
			continue;
		}
		if (await configureExtension(editor, apiKey)) results.set(editor, "success");
		else results.set(editor, "success");
	}
	for (const editor of mcpToConfigure) {
		const status = await installMCPServerForEditor(homeDir, workspaceDir, editor, apiKey);
		results.set(editor, status);
	}
	return results;
}

//#endregion
export { installNeon };
//# sourceMappingURL=install.js.map