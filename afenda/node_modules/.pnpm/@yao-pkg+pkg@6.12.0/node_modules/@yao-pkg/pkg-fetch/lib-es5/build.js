"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepBuildPath = exports.fetchExtractApply = void 0;
const zlib_1 = require("zlib");
const crypto_1 = __importDefault(require("crypto"));
const fs_1 = require("fs");
const promises_1 = require("fs/promises");
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const stream_1 = require("stream");
const util_1 = require("util");
const tar_fs_1 = __importDefault(require("tar-fs"));
const places_1 = require("./places");
const utils_1 = require("./utils");
const system_1 = require("./system");
const log_1 = require("./log");
const patches_json_1 = __importDefault(require("../patches/patches.json"));
const buildPath = path_1.default.resolve(process.env.PKG_BUILD_PATH ||
    path_1.default.join(os_1.default.tmpdir(), `pkg.${crypto_1.default.randomBytes(12).toString('hex')}`));
const nodePath = path_1.default.join(buildPath, 'node');
const patchesPath = path_1.default.resolve(__dirname, '../patches');
const nodeRepo = 'https://nodejs.org/dist';
const nodeArchivePath = path_1.default.join(places_1.cachePath, 'node');
function getMajor(nodeVersion) {
    const [, version] = nodeVersion.match(/^v?(\d+)/) || ['', 0];
    return Number(version) | 0;
}
function getConfigureArgs(major, targetPlatform, targetArch) {
    const args = [];
    // first of all v8_inspector introduces the use
    // of `prime_rehash_policy` symbol that requires
    // GLIBCXX_3.4.18 on some systems
    // also we don't support any kind of debugging
    // against packaged apps, hence v8_inspector is useless
    args.push('--without-inspector');
    if (system_1.hostPlatform === 'alpine') {
        // Statically Link against libgcc and libstdc++ libraries. See vercel/pkg#555.
        // libgcc and libstdc++ grant GCC Runtime Library Exception of GPL
        args.push('--partly-static');
    }
    if (targetPlatform === 'linuxstatic') {
        args.push('--fully-static');
    }
    // Link Time Optimization
    if (major >= 12) {
        if (system_1.hostPlatform !== 'win') {
            args.push('--enable-lto');
        }
    }
    // production binaries do NOT take NODE_OPTIONS from end-users
    args.push('--without-node-options');
    // The dtrace and etw support was removed in https://github.com/nodejs/node/commit/aa3a572e6bee116cde69508dc29478b40f40551a
    if (major <= 18) {
        // DTrace
        args.push('--without-dtrace');
    }
    // bundled npm package manager
    args.push('--without-npm');
    // Small ICU
    if (system_1.hostPlatform !== 'win' || major < 24) {
        args.push('--with-intl=small-icu');
    }
    // Workaround for nodejs/node#39313
    // All supported macOS versions have zlib as a system library
    if (targetPlatform === 'macos') {
        args.push('--shared-zlib');
    }
    // macos cross-build from arm64 to x64
    if (targetPlatform === 'macos' && system_1.hostArch === 'arm64' && targetArch === 'x64') {
        args.push('--dest-os=mac');
        args.push('--dest-cpu=x64');
    }
    return args;
}
async function tarFetch(nodeVersion) {
    log_1.log.info('Fetching Node.js source archive from nodejs.org...');
    const distUrl = `${nodeRepo}/${nodeVersion}`;
    const tarName = `node-${nodeVersion}.tar.gz`;
    const archivePath = path_1.default.join(nodeArchivePath, tarName);
    const hashPath = path_1.default.join(nodeArchivePath, `${tarName}.sha256sum`);
    if ((0, fs_1.existsSync)(hashPath) && (0, fs_1.existsSync)(archivePath)) {
        return;
    }
    await (0, promises_1.rm)(hashPath, { recursive: true, force: true }).catch(() => undefined);
    await (0, promises_1.rm)(archivePath, { recursive: true, force: true }).catch(() => undefined);
    await (0, utils_1.downloadUrl)(`${distUrl}/SHASUMS256.txt`, hashPath);
    await (0, promises_1.writeFile)(hashPath, (await (0, promises_1.readFile)(hashPath, 'utf8'))
        .split('\n')
        .filter((l) => l.includes(tarName))[0]);
    await (0, utils_1.downloadUrl)(`${distUrl}/${tarName}`, archivePath);
}
async function tarExtract(nodeVersion, suppressTarOutput) {
    log_1.log.info('Extracting Node.js source archive...');
    const tarName = `node-${nodeVersion}.tar.gz`;
    const expectedHash = (await (0, promises_1.readFile)(path_1.default.join(nodeArchivePath, `${tarName}.sha256sum`), 'utf8')).split(' ')[0];
    const actualHash = await (0, utils_1.hash)(path_1.default.join(nodeArchivePath, tarName));
    if (expectedHash !== actualHash) {
        await (0, promises_1.rm)(path_1.default.join(nodeArchivePath, tarName), {
            recursive: true,
            force: true,
        });
        await (0, promises_1.rm)(path_1.default.join(nodeArchivePath, `${tarName}.sha256sum`), {
            recursive: true,
            force: true,
        });
        throw (0, log_1.wasReported)(`Hash mismatch for ${tarName}`);
    }
    const pipe = (0, util_1.promisify)(stream_1.pipeline);
    const source = (0, fs_1.createReadStream)(path_1.default.join(nodeArchivePath, tarName));
    const gunzip = (0, zlib_1.createGunzip)();
    const extract = tar_fs_1.default.extract(nodePath, {
        strip: 1,
        map: (header) => {
            if (!suppressTarOutput) {
                // disabled for now - can't get cmdline flag to work with all builds
                // log.info(header.name);
            }
            return header;
        },
    });
    await pipe(source, gunzip, extract);
}
async function applyPatches(nodeVersion) {
    log_1.log.info('Applying patches');
    const storedPatches = patches_json_1.default[nodeVersion];
    const storedPatch = 'patches' in storedPatches ? storedPatches.patches : storedPatches;
    const patches = 'sameAs' in storedPatch
        ? patches_json_1.default[storedPatch.sameAs]
        : storedPatch;
    for (const patch of patches) {
        const patchPath = path_1.default.join(patchesPath, patch);
        const args = ['-p1', '-i', patchPath];
        await (0, utils_1.spawn)('patch', args, { cwd: nodePath, stdio: 'inherit' });
    }
}
async function fetchExtractApply(nodeVersion, quietExtraction) {
    await tarFetch(nodeVersion);
    await tarExtract(nodeVersion, quietExtraction);
    await applyPatches(nodeVersion);
}
exports.fetchExtractApply = fetchExtractApply;
async function compileOnWindows(nodeVersion, targetArch, targetPlatform) {
    const args = ['/c', 'vcbuild.bat', targetArch];
    const major = getMajor(nodeVersion);
    const config_flags = getConfigureArgs(major, targetPlatform, targetArch);
    // The dtrace and etw support was removed in https://github.com/nodejs/node/commit/aa3a572e6bee116cde69508dc29478b40f40551a
    if (major <= 18) {
        // Event Tracing for Windows
        args.push('noetw');
    }
    // Performance counters on Windows
    if (major <= 10) {
        args.push('noperfctr');
    }
    // Link Time Code Generation
    if (major >= 12) {
        args.push('ltcg');
    }
    // Node24 builds on Windows crash with small-icu at icudat codegen
    // workaround for now is to enable full-icu
    // TODO check with newer node/tooling/gh-image versions
    if (major >= 24) {
        args.push('full-icu');
    }
    // Can't cross compile for arm64 with small-icu
    if (major < 24 &&
        system_1.hostArch !== targetArch &&
        !config_flags.includes('--with-intl=full-icu')) {
        config_flags.push('--without-intl');
    }
    await (0, utils_1.spawn)('cmd', args, {
        cwd: nodePath,
        env: { ...process.env, config_flags: config_flags.join(' ') },
        stdio: 'inherit',
    });
    if (major <= 10) {
        return path_1.default.join(nodePath, 'Release/node.exe');
    }
    return path_1.default.join(nodePath, 'out/Release/node.exe');
}
const { MAKE_JOB_COUNT = os_1.default.cpus().length } = process.env;
async function compileOnUnix(nodeVersion, targetArch, targetPlatform) {
    const args = [];
    const cpu = {
        x86: 'ia32',
        x64: 'x64',
        armv6: 'arm',
        armv7: 'arm',
        arm64: 'arm64',
        ppc64: 'ppc64',
        s390x: 's390x',
    }[targetArch];
    if (cpu) {
        args.push('--dest-cpu', cpu);
    }
    if (targetArch === 'armv7') {
        const { CFLAGS = '', CXXFLAGS = '' } = process.env;
        process.env.CFLAGS = `${CFLAGS} -marm -mcpu=cortex-a7 -mfpu=vfpv3`;
        process.env.CXXFLAGS = `${CXXFLAGS} -marm -mcpu=cortex-a7 -mfpu=vfpv3`;
        args.push('--with-arm-float-abi=hard');
        args.push('--with-arm-fpu=vfpv3');
    }
    // macos cross-build from arm64 to x64
    if (targetPlatform === "macos" && system_1.hostArch === 'arm64' && targetArch === 'x64') {
        const { CFLAGS = '', CXXFLAGS = '', LDFLAGS = '' } = process.env;
        process.env.CFLAGS = `${CFLAGS} -arch x86_64`;
        process.env.CXXFLAGS = `${CXXFLAGS} -arch x86_64`;
        process.env.LDFLAGS = `${LDFLAGS} -arch x86_64`;
    }
    if (system_1.hostArch !== targetArch) {
        log_1.log.warn('Cross compiling!');
        log_1.log.warn('You are responsible for appropriate env like CC, CC_host, etc.');
        args.push('--cross-compiling');
    }
    args.push(...getConfigureArgs(getMajor(nodeVersion), targetPlatform, targetArch));
    log_1.log.info("Running configure with: ", args.join(" "));
    // TODO same for windows?
    await (0, utils_1.spawn)('/bin/sh', ['./configure', ...args], {
        cwd: nodePath,
        stdio: 'inherit',
    });
    await (0, utils_1.spawn)(system_1.hostPlatform === 'freebsd' ? 'gmake' : 'make', ['-j', String(MAKE_JOB_COUNT)], {
        cwd: nodePath,
        stdio: 'inherit',
    });
    const output = path_1.default.join(nodePath, 'out/Release/node');
    await (0, utils_1.spawn)(process.env.STRIP || 'strip', 
    // global symbols are required for native bindings on macOS
    [...(targetPlatform === 'macos' ? ['-x'] : []), output], {
        stdio: 'inherit',
    });
    if (targetPlatform === 'macos') {
        // Newer versions of Apple Clang automatically ad-hoc sign the compiled executable.
        // However, for final executable to be signable, base binary MUST NOT have an existing signature.
        await (0, utils_1.spawn)('codesign', ['--remove-signature', output], {
            stdio: 'inherit',
        });
    }
    return output;
}
async function compile(nodeVersion, targetArch, targetPlatform) {
    log_1.log.info('Compiling Node.js from sources...');
    const win = system_1.hostPlatform === 'win';
    if (win) {
        return compileOnWindows(nodeVersion, targetArch, targetPlatform);
    }
    return compileOnUnix(nodeVersion, targetArch, targetPlatform);
}
async function prepBuildPath() {
    await (0, promises_1.rm)(buildPath, { recursive: true, force: true });
    await (0, promises_1.mkdir)(nodePath, { recursive: true });
    await (0, promises_1.mkdir)(nodeArchivePath, { recursive: true });
}
exports.prepBuildPath = prepBuildPath;
async function build(nodeVersion, targetArch, targetPlatform, local) {
    await prepBuildPath();
    await fetchExtractApply(nodeVersion, false);
    const output = await compile(nodeVersion, targetArch, targetPlatform);
    const outputHash = await (0, utils_1.hash)(output);
    await (0, promises_1.mkdir)(path_1.default.dirname(local), { recursive: true });
    await (0, promises_1.cp)(output, local);
    await (0, promises_1.writeFile)(`${local}.sha256sum`, `${outputHash}  ${path_1.default.basename(local)}
`);
    await (0, promises_1.rm)(buildPath, { recursive: true, force: true });
}
exports.default = build;
//# sourceMappingURL=build.js.map